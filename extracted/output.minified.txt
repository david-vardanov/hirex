// src/App.vue
<template>  <ion-app>    <ion-router-outlet />    <transition-overlay v-if="isTransitioning" />  </ion-app></template><script lang="ts">import { IonApp, IonRouterOutlet } from '@ionic/vue';import { defineComponent, ref, onMounted } from 'vue';import { useRouter } from 'vue-router';import TransitionOverlay from '@/components/common/TransitionOverlay.vue';import { useAppStore } from '@/store/appStore';export default defineComponent({  name: 'App',  components: {    IonApp,    IonRouterOutlet,    TransitionOverlay  },  setup() {    const router = useRouter();    const appStore = useAppStore();    const isTransitioning = ref<boolean>(false);    // Handle global route transitions    router.beforeEach((to, from, next) => {      if (to.meta.requiresTransition && from.name) {        isTransitioning.value = true;        setTimeout(() => {          isTransitioning.value = false;          next();        }, 500); // Adjust timing as needed      } else {        next();      }    });    // Initialize app    onMounted(() => {      // Check for saved session with additional error handling      try {        const savedToken = localStorage.getItem('auth_token');        if (savedToken) {          appStore.restoreSession(savedToken)            .catch((error: Error) => {              console.error('[SessionRestore] Failed to restore session:', error);              localStorage.removeItem('auth_token');            });        }      } catch (error) {        console.error('[AppInit] Critical initialization error:', error);        // Fallback to safe state        localStorage.removeItem('auth_token');      }    });    return {      isTransitioning    };  }});</script><style lang="scss">


// src/types/index.ts
/** * Core application type definitions */export interface ApiSuccessResponse<T = any> {  success: true;  data: T;  status: number;  headers?: Record<string, string>;}export interface ApiErrorDetail {  message: string;  type: string;  status?: number;  code?: string;  data?: any;}export interface ApiErrorResponse {  success: false;  error: ApiErrorDetail;  originalError?: Error;}export type ApiResponse<T = any> = ApiSuccessResponse<T> | ApiErrorResponse;export interface UserCredentials {  email: string;  password: string;}export interface UserProfile {  id: string;  email: string;  name: string;  phone?: string;  photo?: string;  profession?: string;  experience?: number;  bio?: string;  skills?: string[];  cvUrl?: string;  createdAt: string;  updatedAt: string;}export interface ApplicationStatus {  id: string;  status:    | "pending"    | "reviewing"    | "interview_scheduled"    | "approved"    | "rejected";  currentStage: number;  totalStages: number;  lastUpdated: string;  nextAction?: {    type: "call" | "interview" | "document" | "wait";    dueDate?: string;    description?: string;  };  timeline: Array<{    date: string;    action: string;    status: "completed" | "current" | "upcoming";  }>;}export interface Notification {  id: string | number;  title: string;  message: string;  type: "info" | "success" | "warning" | "error";  timestamp: Date;  read: boolean;  actionUrl?: string;  actionText?: string;}export interface NotificationPreferences {  email: boolean;  push: boolean;  sms: boolean;  applicationUpdates: boolean;  interviewReminders: boolean;  generalAnnouncements: boolean;}export interface UploadProgressEvent {  loaded: number;  total: number;  percentage: number;}export interface RegistrationData {  email: string;  password: string;  name: string;  phone?: string;  profession?: string;  experience?: number;  skills?: string[];  bio?: string;  termsAccepted: boolean;}export class ValidationError extends Error {  constructor(message: string) {    super(message);    this.name = "ValidationError";  }}export class AuthenticationError extends Error {  constructor(message: string) {    super(message);    this.name = "AuthenticationError";  }}export class NetworkError extends Error {  constructor(message: string) {    super(message);    this.name = "NetworkError";  }}export class AppError extends Error {  code?: string;  status?: number;  data?: any;  constructor(    message: string,    options?: { code?: string; status?: number; data?: any }  ) {    super(message);    this.name = "AppError";    if (options) {      this.code = options.code;      this.status = options.status;      this.data = options.data;    }  }}


// src/main.ts
import { createApp } from "vue";import { IonicVue } from "@ionic/vue";import { createPinia } from "pinia";import App from "./App.vue";import router from "./router";import "@ionic/vue/css/core.css";import "@ionic/vue/css/normalize.css";import "@ionic/vue/css/structure.css";import "@ionic/vue/css/typography.css";import "@ionic/vue/css/padding.css";import "@ionic/vue/css/float-elements.css";import "@ionic/vue/css/text-alignment.css";import "@ionic/vue/css/text-transformation.css";import "@ionic/vue/css/flex-utils.css";import "@ionic/vue/css/display.css";import "./assets/scss/main.scss";interface ErrorWithInfo {  message: string;  stack?: string;  componentName?: string;  lifecycleHook?: string;}const app = createApp(App).use(IonicVue).use(createPinia()).use(router);app.config.errorHandler = (err: unknown, vm: any, info: string): void => {  const error = err as Error;  const formattedError: ErrorWithInfo = {    message: error.message || "Unknown error",    stack: error.stack,    componentName: vm?.$options?.name || "UnknownComponent",    lifecycleHook: info,  };  console.error("[GlobalErrorHandler]", formattedError);  // Here you would integrate with an error logging service  // logErrorToService(formattedError);};router.isReady().then(() => {  app.mount("#app");});


// src/utils/validators.ts
/** * Validation utility library for form fields and data objects *//** * Base validation rules and error messages */export interface ValidationRule {  validate: (value: any) => boolean;  message: string;}/** * Standard validation rules library */export const Rules = {  required: (message = "This field is required"): ValidationRule => ({    validate: (value) => {      if (value === null || value === undefined) return false;      if (typeof value === "string") return value.trim().length > 0;      if (Array.isArray(value)) return value.length > 0;      if (typeof value === "object") return Object.keys(value).length > 0;      return true;    },    message,  }),  email: (message = "Please enter a valid email address"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;      return pattern.test(String(value).toLowerCase());    },    message,  }),  minLength: (    min: number,    message = `Must be at least ${min} characters`  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return String(value).length >= min;    },    message,  }),  maxLength: (    max: number,    message = `Must be no more than ${max} characters`  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return String(value).length <= max;    },    message,  }),  pattern: (regex: RegExp, message = "Invalid format"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return regex.test(String(value));    },    message,  }),  numeric: (message = "Must be a valid number"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return !isNaN(Number(value));    },    message,  }),  integer: (message = "Must be a whole number"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return Number.isInteger(Number(value));    },    message,  }),  min: (min: number, message = `Must be at least ${min}`): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return Number(value) >= min;    },    message,  }),  max: (    max: number,    message = `Must be no more than ${max}`  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return Number(value) <= max;    },    message,  }),  match: (field: string, message = "Fields do not match"): ValidationRule => ({    validate: (value, formValues) => {      if (!value) return true; // Let required rule handle empty fields      return value === formValues[field];    },    message,  }),  strongPassword: (    message = "Password must contain at least 8 characters, including uppercase, lowercase, and numbers"  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      const minLength = value.length >= 8;      const hasUppercase = /[A-Z]/.test(value);      const hasLowercase = /[a-z]/.test(value);      const hasNumbers = /\d/.test(value);      return minLength && hasUppercase && hasLowercase && hasNumbers;    },    message,  }),  url: (message = "Please enter a valid URL"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      try {        new URL(value);        return true;      } catch (e) {        return false;      }    },    message,  }),  date: (message = "Please enter a valid date"): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      return !isNaN(Date.parse(value));    },    message,  }),  fileType: (    types: string[],    message = `Accepted file types: ${types.join(", ")}`  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      // Handle file input element      if (value instanceof HTMLInputElement && value.type === "file") {        if (!value.files || value.files.length === 0) return true;        const file = value.files[0];        return types.some((type) => file.type.includes(type));      }      // Handle File object      if (value instanceof File) {        return types.some((type) => value.type.includes(type));      }      return true;    },    message,  }),  maxFileSize: (    sizeInMB: number,    message = `File must be smaller than ${sizeInMB}MB`  ): ValidationRule => ({    validate: (value) => {      if (!value) return true; // Let required rule handle empty fields      // Handle file input element      if (value instanceof HTMLInputElement && value.type === "file") {        if (!value.files || value.files.length === 0) return true;        const file = value.files[0];        return file.size <= sizeInMB * 1024 * 1024;      }      // Handle File object      if (value instanceof File) {        return value.size <= sizeInMB * 1024 * 1024;      }      return true;    },    message,  }),  custom: (    validateFn: (value: any, formValues?: any) => boolean,    message = "Invalid value"  ): ValidationRule => ({    validate: validateFn,    message,  }),};/** * Validate a single value against provided rules * @param value - Value to validate * @param rules - Validation rules to apply * @param formValues - Optional form values for cross-field validation * @returns Object containing validation result */export function validateField(  value: any,  rules: ValidationRule[],  formValues?: Record<string, any>): { valid: boolean; errors: string[] } {  try {    const errors: string[] = [];    for (const rule of rules) {      const isValid = rule.validate(value, formValues);      if (!isValid) {        errors.push(rule.message);      }    }    return {      valid: errors.length === 0,      errors,    };  } catch (error) {    console.error("[Validator] Error in validateField:", error);    return {      valid: false,      errors: ["Validation error occurred"],    };  }}/** * Validate all fields in a form object * @param formData - Form data object * @param validationSchema - Validation schema * @returns Object containing validation results */export function validateForm(  formData: Record<string, any>,  validationSchema: Record<string, ValidationRule[]>): {  valid: boolean;  errors: Record<string, string[]>;  firstErrorField?: string;} {  try {    const result: Record<string, string[]> = {};    let valid = true;    let firstErrorField: string | undefined;    for (const field in validationSchema) {      if (Object.prototype.hasOwnProperty.call(validationSchema, field)) {        const rules = validationSchema[field];        const value = formData[field];        const fieldResult = validateField(value, rules, formData);        if (!fieldResult.valid) {          valid = false;          result[field] = fieldResult.errors;          // Record the first field with an error          if (!firstErrorField) {            firstErrorField = field;          }        }      }    }    return {      valid,      errors: result,      firstErrorField,    };  } catch (error) {    console.error("[Validator] Error in validateForm:", error);    return {      valid: false,      errors: {        _form: ["Form validation failed"],      },    };  }}/** * Create a reactive validation object for Vue * @param initialValues - Initial form values * @param validationSchema - Validation schema * @returns Validation object */export function createValidation(  initialValues: Record<string, any>,  validationSchema: Record<string, ValidationRule[]>): {  validate: () => {    valid: boolean;    errors: Record<string, string[]>;    firstErrorField?: string;  };  validateField: (field: string) => { valid: boolean; errors: string[] };  errors: Record<string, string[]>;  touched: Record<string, boolean>;  dirty: Record<string, boolean>;  reset: () => void;  markTouched: (field: string) => void;  markAllTouched: () => void;} {  // Initialize validation state  const errors: Record<string, string[]> = {};  const touched: Record<string, boolean> = {};  const dirty: Record<string, boolean> = {};  // Initialize tracking objects  Object.keys(validationSchema).forEach((field) => {    errors[field] = [];    touched[field] = false;    dirty[field] = false;  });  return {    // Validate entire form    validate() {      const result = validateForm(initialValues, validationSchema);      Object.assign(errors, result.errors);      return result;    },    // Validate single field    validateField(field: string) {      if (!validationSchema[field]) {        console.warn(          `[Validator] Field '${field}' does not exist in validation schema`        );        return { valid: true, errors: [] };      }      const rules = validationSchema[field];      const value = initialValues[field];      const result = validateField(value, rules, initialValues);      errors[field] = result.errors;      return result;    },    // Error messages by field    errors,    // Tracking which fields have been interacted with    touched,    // Tracking which fields have changed from initial values    dirty,    // Reset validation state    reset() {      Object.keys(errors).forEach((field) => {        errors[field] = [];        touched[field] = false;        dirty[field] = false;      });    },    // Mark field as touched (user has interacted with it)    markTouched(field: string) {      if (touched[field] !== undefined) {        touched[field] = true;      }    },    // Mark all fields as touched    markAllTouched() {      Object.keys(touched).forEach((field) => {        touched[field] = true;      });    },  };}export default {  Rules,  validateField,  validateForm,  createValidation,};


// src/utils/animations.ts



// src/components/landing/TestimonialsSlider.vue
<template>    <div class="testimonial-slider">        <!-- Navigation controls -->        <div class="testimonial-controls">            <button class="control-button" :class="{ 'disabled': currentIndex === 0 }" @click="prevSlide"                :disabled="currentIndex === 0">                <ion-icon :icon="chevronBackOutline"></ion-icon>            </button>            <div class="indicators">                <button v-for="(_, index) in testimonials" :key="`indicator-${index}`" class="indicator-dot"                    :class="{ 'active': currentIndex === index }" @click="goToSlide(index)"></button>            </div>            <button class="control-button" :class="{ 'disabled': currentIndex === testimonials.length - 1 }"                @click="nextSlide" :disabled="currentIndex === testimonials.length - 1">                <ion-icon :icon="chevronForwardOutline"></ion-icon>            </button>        </div>        <!-- Testimonial cards container -->        <div class="testimonial-container" ref="sliderContainer">            <div class="testimonial-track" :style="trackStyle" ref="sliderTrack">                <div v-for="(testimonial, index) in testimonials" :key="`testimonial-${testimonial.id || index}`"                    class="testimonial-card" :class="{ 'active': currentIndex === index }" ref="testimonialCards">                    <div class="testimonial-card__content">                        <div class="testimonial-card__quote-icon">                            <ion-icon :icon="quoteIcon"></ion-icon>                        </div>                        <p class="testimonial-card__quote">{{ testimonial.quote }}</p>                        <div class="testimonial-card__rating">                            <div class="stars">                                <ion-icon v-for="star in 5" :key="`star-${star}`"                                    :icon="star <= testimonial.rating ? filledStarIcon : emptyStarIcon"                                    class="star-icon"></ion-icon>                            </div>                        </div>                    </div>                    <div class="testimonial-card__footer">                        <div class="testimonial-card__avatar">                            <img :src="testimonial.image || defaultAvatar" :alt="`${testimonial.name}'s profile`"                                @error="handleImageError" />                        </div>                        <div class="testimonial-card__author">                            <div class="testimonial-card__name">{{ testimonial.name }}</div>                            <div class="testimonial-card__position">                                {{ testimonial.position }}                                <span v-if="testimonial.company">at {{ testimonial.company }}</span>                            </div>                        </div>                    </div>                </div>            </div>        </div>    </div></template><script lang="ts">import { defineComponent, ref, computed, onMounted, onBeforeUnmount, watch, PropType } from 'vue';import { IonIcon } from '@ionic/vue';import {    chevronBackOutline,    chevronForwardOutline,    starOutline,    star,    chatbubbleOutline} from 'ionicons/icons';import gsap from 'gsap';import { ANIMATION_TIMING, EASING } from '@/utils/animations';import defaultAvatarImg from '@/assets/images/default-avatar.svg';interface Testimonial {    id?: number | string;    name: string;    position: string;    company?: string;    image?: string;    quote: string;    rating: number;}export default defineComponent({    name: 'TestimonialSlider',    components: {        IonIcon    },    props: {        testimonials: {            type: Array as PropType<Testimonial[]>,            required: true        },        autoplay: {            type: Boolean,            default: true        },        autoplayInterval: {            type: Number,            default: 5000 // 5 seconds        },        loop: {            type: Boolean,            default: false        }    },    setup(props) {        const currentIndex = ref(0);        const sliderContainer = ref<HTMLElement | null>(null);        const sliderTrack = ref<HTMLElement | null>(null);        const testimonialCards = ref<HTMLElement[]>([]);        const isAnimating = ref(false);        // Default avatar for when image fails to load        const defaultAvatar = defaultAvatarImg;        // Icons        const chevronBackOutline = chevronBackOutline;        const chevronForwardOutline = chevronForwardOutline;        const emptyStarIcon = starOutline;        const filledStarIcon = star;        const quoteIcon = chatbubbleOutline;        // Autoplay interval ID        let autoplayTimer: number | null = null;        // Compute track transform style based on current index        const trackStyle = computed(() => {            return {                transform: `translateX(-${currentIndex.value * 100}%)`,                transition: isAnimating.value ? 'transform 0.5s ease-in-out' : 'none'            };        });        // Navigate to previous slide        const prevSlide = () => {            if (isAnimating.value || currentIndex.value <= 0) return;            isAnimating.value = true;            currentIndex.value--;            animateSlide();            resetAutoplay();        };        // Navigate to next slide        const nextSlide = () => {            if (isAnimating.value || currentIndex.value >= props.testimonials.length - 1) return;            isAnimating.value = true;            currentIndex.value++;            animateSlide();            resetAutoplay();        };        // Go to a specific slide        const goToSlide = (index: number) => {            if (isAnimating.value || index === currentIndex.value) return;            isAnimating.value = true;            currentIndex.value = index;            animateSlide();            resetAutoplay();        };        // Animate the transition between slides        const animateSlide = () => {            const cards = testimonialCards.value;            if (!cards || cards.length === 0) {                isAnimating.value = false;                return;            }            // Use GSAP for smoother animations            gsap.to(sliderTrack.value, {                x: `-${currentIndex.value * 100}%`,                duration: ANIMATION_TIMING.MEDIUM,                ease: EASING.EASE_IN_OUT,                onComplete: () => {                    isAnimating.value = false;                }            });            // Animate the active card            const activeCard = cards[currentIndex.value];            if (activeCard) {                gsap.fromTo(                    activeCard,                    {                        opacity: 0,                        y: 20                    },                    {                        opacity: 1,                        y: 0,                        duration: ANIMATION_TIMING.MEDIUM,                        ease: EASING.EASE_OUT,                        delay: 0.1                    }                );            }        };        // Start autoplay if enabled        const startAutoplay = () => {            if (!props.autoplay) return;            stopAutoplay();            autoplayTimer = window.setInterval(() => {                if (currentIndex.value < props.testimonials.length - 1) {                    nextSlide();                } else if (props.loop) {                    // Reset to first slide if loop is enabled                    goToSlide(0);                }            }, props.autoplayInterval);        };        // Stop autoplay        const stopAutoplay = () => {            if (autoplayTimer !== null) {                clearInterval(autoplayTimer);                autoplayTimer = null;            }        };        // Reset autoplay timer        const resetAutoplay = () => {            stopAutoplay();            startAutoplay();        };        // Handle image loading errors        const handleImageError = (event: Event) => {            const img = event.target as HTMLImageElement;            img.src = defaultAvatar;        };        // Initialize the slider on mount        onMounted(() => {            startAutoplay();            // Initial animation for the first card            const firstCard = testimonialCards.value[0];            if (firstCard) {                gsap.fromTo(                    firstCard,                    {                        opacity: 0,                        y: 20                    },                    {                        opacity: 1,                        y: 0,                        duration: ANIMATION_TIMING.MEDIUM,                        ease: EASING.EASE_OUT                    }                );            }            // Pause autoplay when user interacts with the slider            sliderContainer.value?.addEventListener('mouseenter', stopAutoplay);            sliderContainer.value?.addEventListener('mouseleave', startAutoplay);        });        // Clean up on unmount        onBeforeUnmount(() => {            stopAutoplay();            // Remove event listeners            sliderContainer.value?.removeEventListener('mouseenter', stopAutoplay);            sliderContainer.value?.removeEventListener('mouseleave', startAutoplay);        });        // Watch for testimonials changes        watch(() => props.testimonials, () => {            // Reset slider when testimonials change            currentIndex.value = 0;            isAnimating.value = false;            resetAutoplay();        });        return {            currentIndex,            sliderContainer,            sliderTrack,            testimonialCards,            isAnimating,            trackStyle,            prevSlide,            nextSlide,            goToSlide,            defaultAvatar,            handleImageError,            chevronBackOutline,            chevronForwardOutline,            emptyStarIcon,            filledStarIcon,            quoteIcon        };    }});</script><style lang="scss" scoped>@import '@/assets/scss/variables.scss';.testimonial-slider {    position: relative;    width: 100%;    margin: 0 auto;    overflow: hidden;}.testimonial-controls {    display: flex;    align-items: center;    justify-content: center;    margin-bottom: $spacing-lg;}.control-button {    display: flex;    align-items: center;    justify-content: center;    width: 40px;    height: 40px;    border-radius: 50%;    background-color: #fff;    border: 1px solid $gray-200;    color: var(--ion-color-dark);    font-size: 1.25rem;    cursor: pointer;    transition: all 0.3s ease;    &:hover:not(.disabled) {        background-color: var(--ion-color-primary);        border-color: var(--ion-color-primary);        color: #fff;    }    &.disabled {        opacity: 0.5;        cursor: not-allowed;    }}.indicators {    display: flex;    align-items: center;    justify-content: center;    margin: 0 $spacing-md;}.indicator-dot {    width: 10px;    height: 10px;    border-radius: 50%;    background-color: $gray-300;    margin: 0 $spacing-xxs;    border: none;    padding: 0;    cursor: pointer;    transition: all 0.3s ease;    &.active {        width: 12px;        height: 12px;        background-color: var(--ion-color-primary);    }    &:hover:not(.active) {        background-color: $gray-400;    }}.testimonial-container {    position: relative;    width: 100%;    overflow: hidden;}.testimonial-track {    display: flex;    transition: transform 0.5s ease-in-out;    width: 100%;}.testimonial-card {    flex: 0 0 100%;    padding: $spacing-md;    opacity: 0.5;    transition: opacity 0.5s ease;    &.active {        opacity: 1;    }    @media (min-width: $breakpoint-md) {        padding: $spacing-lg;    }    &__content {        background-color: #fff;        border-radius: $border-radius-lg;        padding: $spacing-xl;        margin-bottom: $spacing-md;        box-shadow: $shadow-md;        position: relative;        &::after {            content: '';            position: absolute;            bottom: -10px;            left: 30px;            width: 20px;            height: 20px;            background-color: #fff;            transform: rotate(45deg);            box-shadow: 2px 2px 2px rgba(0, 0, 0, 0.05);        }    }    &__quote-icon {        color: var(--ion-color-primary);        font-size: 1.5rem;        margin-bottom: $spacing-md;        opacity: 0.5;    }    &__quote {        font-size: 1.125rem;        line-height: 1.6;        color: $gray-700;        font-style: italic;        margin-bottom: $spacing-md;    }    &__rating {        display: flex;        align-items: center;        margin-bottom: $spacing-sm;        .stars {            display: flex;        }        .star-icon {            color: #FFD700;            margin-right: 2px;            font-size: 1.25rem;        }    }    &__footer {        display: flex;        align-items: center;        padding-left: $spacing-lg;    }    &__avatar {        width: 50px;        height: 50px;        border-radius: 50%;        overflow: hidden;        margin-right: $spacing-md;        border: 2px solid #fff;        box-shadow: $shadow-sm;        img {            width: 100%;            height: 100%;            object-fit: cover;        }    }    &__author {        display: flex;        flex-direction: column;    }    &__name {        font-weight: $font-weight-semibold;        font-size: 1.125rem;        color: var(--ion-color-dark);        margin-bottom: 2px;    }    &__position {        font-size: 0.875rem;        color: $gray-600;    }}@media (min-width: $breakpoint-lg) {    .testimonial-slider {        max-width: 800px;    }}</style>


// src/components/landing/FeatureCard.vue
<template>    <ion-page>        <ion-header class="ion-no-border" translucent>            <ion-toolbar>                <div class="landing-header">                    <div class="landing-logo">                        <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                        <span class="logo-text">JobMatch</span>                    </div>                    <ion-buttons slot="end" class="landing-nav">                        <a href="#features" class="nav-link">Features</a>                        <a href="#how-it-works" class="nav-link">How It Works</a>                        <a href="#testimonials" class="nav-link">Testimonials</a>                        <app-button size="small" variant="secondary" @click="navigateToLogin">                            Log In                        </app-button>                    </ion-buttons>                    <!-- Mobile menu button -->                    <ion-button fill="clear" class="menu-button d-md-none" @click="toggleMobileMenu">                        <ion-icon :icon="menuIcon" slot="icon-only"></ion-icon>                    </ion-button>                </div>            </ion-toolbar>        </ion-header>        <!-- Mobile menu drawer -->        <div class="mobile-menu-overlay" :class="{ 'is-active': mobileMenuOpen }" @click="closeMobileMenu"></div>        <div class="mobile-menu" :class="{ 'is-active': mobileMenuOpen }">            <div class="mobile-menu__header">                <div class="landing-logo">                    <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                    <span class="logo-text">JobMatch</span>                </div>                <ion-button fill="clear" @click="closeMobileMenu">                    <ion-icon :icon="closeIcon" slot="icon-only"></ion-icon>                </ion-button>            </div>            <div class="mobile-menu__links">                <a href="#features" class="mobile-nav-link" @click="closeMobileMenu">Features</a>                <a href="#how-it-works" class="mobile-nav-link" @click="closeMobileMenu">How It Works</a>                <a href="#testimonials" class="mobile-nav-link" @click="closeMobileMenu">Testimonials</a>                <app-button class="mt-lg" block variant="secondary" @click="navigateToLogin">                    Log In                </app-button>                <app-button class="mt-md" block @click="navigateToRegister">                    Create Account                </app-button>            </div>        </div>        <ion-content fullscreen>            <!-- Hero Section -->            <section class="hero-section" id="hero">                <animated-background variant="gradient">                    <div class="content-container hero-content">                        <div class="hero-text animate-slide-in-left">                            <h1 class="hero-title">Find Your Dream Job with Confidence</h1>                            <p class="hero-subtitle">                                Know exactly where you stand in the hiring process.                                No more waiting in uncertainty - get real-time updates on your application.                            </p>                            <div class="hero-cta">                                <app-button size="large" @click="navigateToRegister" leftIcon="person-add-outline">                                    Create Your Profile                                </app-button>                                <app-button size="large" variant="light" @click="scrollToSection('how-it-works')"                                    leftIcon="information-circle-outline">                                    How It Works                                </app-button>                            </div>                        </div>                        <div class="hero-image animate-fade-in animation-delay-300">                            <img src="@/assets/images/hero-image.svg" alt="Candidate Platform" />                        </div>                    </div>                </animated-background>            </section>            <!-- Stats Section -->            <section class="stats-section animate-fade-in">                <div class="content-container">                    <div class="stats-grid">                        <div class="stat-card">                            <div class="stat-number">2,500+</div>                            <div class="stat-label">Companies</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">50,000+</div>                            <div class="stat-label">Candidates</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">85%</div>                            <div class="stat-label">Interview Rate</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">30%</div>                            <div class="stat-label">Faster Hiring</div>                        </div>                    </div>                </div>            </section>            <!-- Features Section -->            <section class="features-section" id="features">                <div class="content-container">                    <div class="section-header stagger-children stagger-fade-in">                        <h2 class="section-title">Features Designed for You</h2>                        <p class="section-subtitle">                            Our platform offers transparency and control throughout your job application journey                        </p>                    </div>                    <div class="features-grid">                        <feature-card title="Real-time Status Updates"                            description="Always know where you stand in the application process with instant notifications."                            icon="time-outline" />                        <feature-card title="Interview Scheduling"                            description="Schedule interviews directly in the platform and receive reminders."                            icon="calendar-outline" />                        <feature-card title="Document Management"                            description="Upload and manage your CV, portfolio, and other documents in one place."                            icon="document-text-outline" />                        <feature-card title="Feedback Collection"                            description="Receive constructive feedback from recruiters to improve your profile."                            icon="chatbubble-outline" />                        <feature-card title="Application Timeline"                            description="Visualize your application journey and upcoming steps in an interactive timeline."                            icon="analytics-outline" />                        <feature-card title="Direct Messaging"                            description="Communicate directly with recruiters to clarify questions and details."                            icon="mail-outline" />                    </div>                </div>            </section>            <!-- How It Works -->            <section class="how-it-works-section" id="how-it-works">                <div class="content-container">                    <div class="section-header">                        <h2 class="section-title">How It Works</h2>                        <p class="section-subtitle">                            Four simple steps to finding your perfect job match                        </p>                    </div>                    <div class="steps-container">                        <div class="step-card" v-for="(step, index) in steps" :key="`step-${index}`">                            <div class="step-number">{{ index + 1 }}</div>                            <div class="step-content">                                <h3 class="step-title">{{ step.title }}</h3>                                <p class="step-description">{{ step.description }}</p>                            </div>                            <div class="step-icon">                                <ion-icon :icon="step.icon"></ion-icon>                            </div>                        </div>                        <div class="step-connector"></div>                    </div>                </div>            </section>            <!-- Testimonials Section -->            <section class="testimonials-section" id="testimonials">                <div class="content-container">                    <div class="section-header">                        <h2 class="section-title">What Our Users Say</h2>                        <p class="section-subtitle">                            Success stories from candidates who found their dream jobs                        </p>                    </div>                    <testimonial-slider :testimonials="testimonials" />                </div>            </section>            <!-- CTA Section -->            <section class="cta-section">                <animated-background variant="primary" :element-count="8">                    <div class="content-container">                        <div class="cta-content">                            <h2 class="cta-title">Ready to take control of your job search?</h2>                            <p class="cta-subtitle">                                Create your profile today and experience a transparent hiring process.                            </p>                            <app-button size="large" variant="light" @click="navigateToRegister">                                Get Started Now                            </app-button>                        </div>                    </div>                </animated-background>            </section>            <!-- Footer -->            <footer class="landing-footer">                <div class="content-container">                    <div class="footer-grid">                        <div class="footer-brand">                            <div class="landing-logo">                                <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                                <span class="logo-text">JobMatch</span>                            </div>                            <p class="footer-tagline">                                Connecting talented candidates with great opportunities.                            </p>                            <div class="social-links">                                <a href="#" class="social-link">                                    <ion-icon name="logo-linkedin"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-twitter"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-facebook"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-instagram"></ion-icon>                                </a>                            </div>                        </div>                        <div class="footer-links">                            <div class="footer-link-group">                                <h4 class="footer-link-title">Platform</h4>                                <a href="#features" class="footer-link">Features</a>                                <a href="#how-it-works" class="footer-link">How It Works</a>                                <a href="#testimonials" class="footer-link">Testimonials</a>                                <a href="#" class="footer-link">Pricing</a>                            </div>                            <div class="footer-link-group">                                <h4 class="footer-link-title">Company</h4>                                <a href="#" class="footer-link">About Us</a>                                <a href="#" class="footer-link">Careers</a>                                <a href="#" class="footer-link">Blog</a>                                <a href="#" class="footer-link">Press</a>                            </div>                            <div class="footer-link-group">                                <h4 class="footer-link-title">Resources</h4>                                <a href="#" class="footer-link">Support</a>                                <a href="#" class="footer-link">Contact</a>                                <a href="#" class="footer-link">Privacy Policy</a>                                <a href="#" class="footer-link">Terms of Service</a>                            </div>                        </div>                    </div>                    <div class="footer-bottom">                        <p class="copyright">Â© 2023 JobMatch. All rights reserved.</p>                        <div class="footer-legal">                            <a href="#" class="legal-link">Privacy Policy</a>                            <a href="#" class="legal-link">Terms of Service</a>                            <a href="#" class="legal-link">Cookie Policy</a>                        </div>                    </div>                </div>            </footer>        </ion-content>    </ion-page></template><script lang="ts">import { defineComponent, ref } from 'vue';import { IonPage, IonHeader, IonToolbar, IonContent, IonButtons, IonButton, IonIcon } from '@ionic/vue';import { useRouter } from 'vue-router';import {    menuOutline,    closeOutline,    timeOutline,    calendarOutline,    documentTextOutline,    chatbubbleOutline,    analyticsOutline,    mailOutline,    personOutline,    briefcaseOutline,    checkmarkCircleOutline,    rocketOutline} from 'ionicons/icons';import AppButton from '@/components/common/Button.vue';import AnimatedBackground from '@/components/common/AnimatedBackground.vue';import FeatureCard from '@/components/landing/FeatureCard.vue';import TestimonialSlider from '@/components/landing/TestimonialSlider.vue';export default defineComponent({    name: 'LandingPage',    components: {        IonPage,        IonHeader,        IonToolbar,        IonContent,        IonButtons,        IonButton,        IonIcon,        AppButton,        AnimatedBackground,        FeatureCard,        TestimonialSlider    },    setup() {        const router = useRouter();        const mobileMenuOpen = ref(false);        // Step data        const steps = [            {                title: 'Create Your Profile',                description: 'Sign up and build your professional profile with your skills, experience, and job preferences.',                icon: personOutline            },            {                title: 'Apply to Jobs',                description: 'Browse available positions that match your skills and apply with just a few clicks.',                icon: briefcaseOutline            },            {                title: 'Track Your Progress',                description: 'Get real-time updates on your application status and upcoming interviews.',                icon: checkmarkCircleOutline            },            {                title: 'Land Your Dream Job',                description: 'Receive offers and accept the position that best fits your career goals.',                icon: rocketOutline            }        ];        // Testimonial data        const testimonials = [            {                id: 1,                name: 'Sarah Johnson',                position: 'Software Developer',                company: 'TechCorp',                image: '@/assets/images/testimonials/testimonial-1.jpg',                quote: 'The transparency of the platform was a game-changer for me. I could see exactly where I was in the hiring process, which eliminated the anxiety of waiting for feedback.',                rating: 5            },            {                id: 2,                name: 'Michael Chen',                position: 'Marketing Manager',                company: 'Brandify',                image: '@/assets/images/testimonials/testimonial-2.jpg',                quote: 'I love how I can schedule interviews directly through the platform. The reminders helped me prepare properly and I ended up getting the job!',                rating: 5            },            {                id: 3,                name: 'Elena Rodriguez',                position: 'UX Designer',                company: 'DesignHub',                image: '@/assets/images/testimonials/testimonial-3.jpg',                quote: 'The feedback I received through JobMatch was invaluable. I could improve my portfolio based on real recruiter comments, which ultimately led to multiple job offers.',                rating: 4            }        ];        // Navigation methods        const navigateToLogin = () => {            router.push('/login');        };        const navigateToRegister = () => {            router.push('/register');        };        // Mobile menu toggle        const toggleMobileMenu = () => {            mobileMenuOpen.value = !mobileMenuOpen.value;            if (mobileMenuOpen.value) {                document.body.classList.add('menu-open');            } else {                document.body.classList.remove('menu-open');            }        };        const closeMobileMenu = () => {            mobileMenuOpen.value = false;            document.body.classList.remove('menu-open');        };        // Smooth scroll to section        const scrollToSection = (sectionId: string) => {            const section = document.getElementById(sectionId);            if (section) {                section.scrollIntoView({ behavior: 'smooth' });            }            closeMobileMenu();        };        return {            mobileMenuOpen,            steps,            testimonials,            menuIcon: menuOutline,            closeIcon: closeOutline,            navigateToLogin,            navigateToRegister,            toggleMobileMenu,            closeMobileMenu,            scrollToSection        };    }});</script><style lang="scss" scoped>@import '@/assets/scss/variables.scss';.landing-header {    display: flex;    align-items: center;    justify-content: space-between;    width: 100%;    padding: $spacing-xs $spacing-md;}.landing-logo {    display: flex;    align-items: center;    .logo-image {        height: 32px;        width: auto;        margin-right: $spacing-xs;    }    .logo-text {        font-size: 1.25rem;        font-weight: $font-weight-bold;        color: var(--ion-color-dark);    }}.landing-nav {    display: none;    @media (min-width: $breakpoint-md) {        display: flex;        align-items: center;    }    .nav-link {        margin-right: $spacing-lg;        font-size: 1rem;        font-weight: $font-weight-medium;        color: var(--ion-color-dark);        text-decoration: none;        transition: color $transition-fast;        &:hover {            color: var(--ion-color-primary);            text-decoration: none;        }    }}.menu-button {    font-size: 1.5rem;}.mobile-menu-overlay {    position: fixed;    top: 0;    left: 0;    right: 0;    bottom: 0;    background-color: rgba(0, 0, 0, 0.5);    z-index: $z-index-modal-backdrop;    opacity: 0;    visibility: hidden;    transition: opacity 0.3s ease, visibility 0.3s ease;    &.is-active {        opacity: 1;        visibility: visible;    }}.mobile-menu {    position: fixed;    top: 0;    right: 0;    width: 80%;    max-width: 320px;    height: 100%;    background-color: #fff;    z-index: $z-index-modal;    transform: translateX(100%);    transition: transform 0.3s ease;    display: flex;    flex-direction: column;    box-shadow: $shadow-lg;    &.is-active {        transform: translateX(0);    }    &__header {        display: flex;        align-items: center;        justify-content: space-between;        padding: $spacing-md;        border-bottom: 1px solid $gray-200;    }    &__links {        padding: $spacing-md;        display: flex;        flex-direction: column;        flex-grow: 1;    }    .mobile-nav-link {        font-size: 1.125rem;        font-weight: $font-weight-medium;        color: var(--ion-color-dark);        text-decoration: none;        padding: $spacing-md 0;        border-bottom: 1px solid $gray-100;        transition: color $transition-fast;        &:hover {            color: var(--ion-color-primary);        }    }}:global(body.menu-open) {    overflow: hidden;}.hero-section {    min-height: 90vh;    display: flex;    align-items: center;    overflow: hidden;    position: relative;}.hero-content {    display: flex;    flex-direction: column;    align-items: center;    padding: $spacing-xl 0;    @media (min-width: $breakpoint-md) {        flex-direction: row;        align-items: center;        padding: $spacing-xxl 0;    }}.hero-text {    flex: 1;    text-align: center;    margin-bottom: $spacing-xl;    @media (min-width: $breakpoint-md) {        text-align: left;        margin-bottom: 0;        margin-right: $spacing-xl;    }}.hero-title {    font-size: 2.25rem;    font-weight: $font-weight-bold;    margin-bottom: $spacing-md;    color: #fff;    line-height: 1.2;    @media (min-width: $breakpoint-md) {        font-size: 3rem;    }}.hero-subtitle {    font-size: 1.125rem;    margin-bottom: $spacing-lg;    color: rgba(255, 255, 255, 0.9);    line-height: 1.6;    @media (min-width: $breakpoint-md) {        font-size: 1.25rem;    }}.hero-cta {    display: flex;    flex-direction: column;    gap: $spacing-md;    @media (min-width: $breakpoint-sm) {        flex-direction: row;        justify-content: center;    }    @media (min-width: $breakpoint-md) {        justify-content: flex-start;    }}.hero-image {    flex: 1;    display: flex;    justify-content: center;    img {        max-width: 100%;        height: auto;        max-height: 400px;        @media (min-width: $breakpoint-md) {            max-height: 500px;        }    }}.stats-section {    background-color: #fff;    padding: $spacing-xl 0;    border-bottom: 1px solid $gray-200;}.stats-grid {    display: grid;    grid-template-columns: repeat(2, 1fr);    gap: $spacing-md;    @media (min-width: $breakpoint-md) {        grid-template-columns: repeat(4, 1fr);    }}.stat-card {    text-align: center;    padding: $spacing-lg;    .stat-number {        font-size: 2rem;        font-weight: $font-weight-bold;        color: var(--ion-color-primary);        margin-bottom: $spacing-xs;        @media (min-width: $breakpoint-md) {            font-size: 2.5rem;        }    }    .stat-label {        font-size: 1rem;        color: $gray-600;        font-weight: $font-weight-medium;    }}.section-header {    text-align: center;    margin-bottom: $spacing-xl;    max-width: 800px;    margin-left: auto;    margin-right: auto;}.section-title {    font-size: 2rem;    font-weight: $font-weight-bold;    color: var(--ion-color-dark);    margin-bottom: $spacing-md;    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.section-subtitle {    font-size: 1.125rem;    color: $gray-600;    line-height: 1.6;}.features-section {    padding: $spacing-xxl 0;    background-color: $gray-50;}.features-grid {    display: grid;    grid-template-columns: 1fr;    gap: $spacing-lg;    @media (min-width: $breakpoint-sm) {        grid-template-columns: repeat(2, 1fr);    }    @media (min-width: $breakpoint-lg) {        grid-template-columns: repeat(3, 1fr);    }}.how-it-works-section {    padding: $spacing-xxl 0;    background-color: #fff;}.steps-container {    position: relative;    max-width: 800px;    margin: 0 auto;}.step-card {    display: flex;    align-items: flex-start;    margin-bottom: $spacing-xl;    position: relative;    z-index: 1;    background-color: #fff;    padding: $spacing-lg;    border-radius: $border-radius-lg;    box-shadow: $shadow-md;    @media (min-width: $breakpoint-md) {        padding: $spacing-xl;    }    &:last-child {        margin-bottom: 0;    }}.step-number {    display: flex;    align-items: center;    justify-content: center;    width: 40px;    height: 40px;    background-color: var(--ion-color-primary);    color: #fff;    border-radius: 50%;    font-weight: $font-weight-bold;    font-size: 1.25rem;    margin-right: $spacing-md;    flex-shrink: 0;    @media (min-width: $breakpoint-md) {        width: 50px;        height: 50px;        font-size: 1.5rem;    }}.step-content {    flex-grow: 1;}.step-title {    font-size: 1.25rem;    font-weight: $font-weight-semibold;    margin-bottom: $spacing-xs;    color: var(--ion-color-dark);    @media (min-width: $breakpoint-md) {        font-size: 1.5rem;    }}.step-description {    font-size: 1rem;    color: $gray-600;    line-height: 1.6;}.step-icon {    margin-left: $spacing-md;    flex-shrink: 0;    font-size: 2rem;    color: var(--ion-color-secondary);    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.step-connector {    position: absolute;    top: 20px;    bottom: 20px;    left: 20px;    width: 2px;    background-color: var(--ion-color-primary);    z-index: 0;    @media (min-width: $breakpoint-md) {        left: 25px;    }}.testimonials-section {    padding: $spacing-xxl 0;    background-color: $gray-50;}.cta-section {    text-align: center;    overflow: hidden;}.cta-content {    padding: $spacing-xxl 0;    color: #fff;}.cta-title {    font-size: 2rem;    font-weight: $font-weight-bold;    margin-bottom: $spacing-md;    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.cta-subtitle {    font-size: 1.125rem;    margin-bottom: $spacing-lg;    max-width: 600px;    margin-left: auto;    margin-right: auto;    @media (min-width: $breakpoint-md) {        font-size: 1.25rem;    }}.landing-footer {    background-color: $gray-900;    color: $gray-300;    padding: $spacing-xl 0 $spacing-lg;}.footer-grid {    display: grid;    grid-template-columns: 1fr;    gap: $spacing-xl;    margin-bottom: $spacing-xl;    @media (min-width: $breakpoint-md) {        grid-template-columns: 1fr 2fr;    }}.footer-brand {    .landing-logo {        margin-bottom: $spacing-md;        .logo-text {            color: #fff;        }    }}.footer-tagline {    margin-bottom: $spacing-md;    font-size: 1rem;    line-height: 1.6;}.social-links {    display: flex;    gap: $spacing-md;}.social-link {    display: flex;    align-items: center;    justify-content: center;    width: 40px;    height: 40px;    border-radius: 50%;    background-color: rgba(255, 255, 255, 0.1);    color: #fff;    font-size: 1.25rem;    transition: background-color $transition-fast;    &:hover {        background-color: var(--ion-color-primary);    }}.footer-links {    display: grid;    grid-template-columns: repeat(1, 1fr);    gap: $spacing-xl;    @media (min-width: $breakpoint-sm) {        grid-template-columns: repeat(2, 1fr);    }    @media (min-width: $breakpoint-md) {        grid-template-columns: repeat(3, 1fr);    }}.footer-link-group {    .footer-link-title {        color: #fff;        font-size: 1.125rem;        font-weight: $font-weight-semibold;        margin-bottom: $spacing-md;    }    .footer-link {        display: block;        color: $gray-400;        text-decoration: none;        margin-bottom: $spacing-sm;        transition: color $transition-fast;        &:hover {            color: #fff;        }    }}.footer-bottom {    display: flex;    flex-direction: column;    gap: $spacing-md;    padding-top: $spacing-md;    border-top: 1px solid rgba(255, 255, 255, 0.1);    @media (min-width: $breakpoint-md) {        flex-direction: row;        justify-content: space-between;        align-items: center;    }}.copyright {    font-size: 0.875rem;    color: $gray-500;}.footer-legal {    display: flex;    flex-wrap: wrap;    gap: $spacing-md;}.legal-link {    font-size: 0.875rem;    color: $gray-500;    text-decoration: none;    &:hover {        color: #fff;    }}</style>


// src/components/common/TransitionOverlay.vue
<style lang="scss" scoped>.transition-overlay {    position: fixed;    top: 0;    left: 0;    width: 100%;    height: 100%;    z-index: 9999;    display: flex;    align-items: center;    justify-content: center;    background-color: rgba(0, 0, 0, 0.7);    opacity: 0;    pointer-events: none;    &--active {        pointer-events: auto;    }    &__content {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;    }    &__spinner {        width: 50px;        height: 50px;    }}</style><template>    <div class="transition-overlay" :class="{ 'transition-overlay--active': active }" ref="overlayRef">        <div class="transition-overlay__content">            <ion-spinner name="crescent" color="light" class="transition-overlay__spinner"></ion-spinner>        </div>    </div></template><script lang="ts">import { defineComponent, ref, onMounted, onBeforeUnmount, watch } from 'vue';import { IonSpinner } from '@ionic/vue';import gsap from 'gsap';import { ANIMATION_TIMING, EASING } from '@/utils/animations';export default defineComponent({    name: 'TransitionOverlay',    components: {        IonSpinner    },    props: {        active: {            type: Boolean,            default: true        },        timeout: {            type: Number,            default: 3000 // Safety timeout to prevent overlay stuck        }    },    setup(props) {        const overlayRef = ref<HTMLElement | null>(null);        let timeoutId: number | undefined;        let animation: gsap.core.Tween | null = null;        /**         * Initialize the overlay animation with error handling         * Creates a fade-in animation for the overlay         */        const initAnimation = () => {            try {                if (!overlayRef.value) {                    console.warn('[TransitionOverlay] Element reference is missing during animation init');                    return;                }                // Kill any existing animation to prevent conflicts                if (animation) {                    animation.kill();                }                // Configure the animation with proper easing and timing                animation = gsap.fromTo(                    overlayRef.value,                    { opacity: 0 },                    {                        opacity: 1,                        duration: ANIMATION_TIMING.STANDARD,                        ease: EASING.PAGE_TRANSITION,                        onComplete: () => {                            // Safety timeout to prevent overlay getting stuck                            initSafetyTimeout();                        }                    }                );                // Pause initially - will be controlled by watcher                animation.pause();            } catch (error) {                console.error('[TransitionOverlay] Animation initialization error:', error);                // Fallback to basic CSS transition if GSAP fails                if (overlayRef.value) {                    overlayRef.value.style.transition = 'opacity 0.4s ease';                    overlayRef.value.style.opacity = '1';                }            }        };        /**         * Set a safety timeout to auto-hide the overlay if it stays visible too long         * Prevents UI getting stuck in a loading state         */        const initSafetyTimeout = () => {            try {                // Clear any existing timeout to prevent duplicates                if (timeoutId) {                    window.clearTimeout(timeoutId);                }                // Set new timeout                timeoutId = window.setTimeout(() => {                    console.warn(`[TransitionOverlay] Safety timeout triggered after ${props.timeout}ms`);                    hideOverlay();                }, props.timeout);            } catch (error) {                console.error('[TransitionOverlay] Safety timeout initialization error:', error);            }        };        /**         * Show the overlay with animation         */        const showOverlay = () => {            try {                if (!animation) {                    initAnimation();                }                if (animation) {                    animation.play();                } else {                    // Fallback if animation wasn't created successfully                    if (overlayRef.value) {                        overlayRef.value.style.opacity = '1';                    }                }                // Always set safety timeout                initSafetyTimeout();            } catch (error) {                console.error('[TransitionOverlay] Show overlay error:', error);                // Attempt to show overlay even if animation fails                if (overlayRef.value) {                    overlayRef.value.style.opacity = '1';                }            }        };        /**         * Hide the overlay with animation         */        const hideOverlay = () => {            try {                // Clear safety timeout when hiding                if (timeoutId) {                    window.clearTimeout(timeoutId);                    timeoutId = undefined;                }                if (animation) {                    // Reverse the animation to hide                    animation.reverse();                } else {                    // Fallback if animation wasn't created successfully                    if (overlayRef.value) {                        overlayRef.value.style.opacity = '0';                    }                }            } catch (error) {                console.error('[TransitionOverlay] Hide overlay error:', error);                // Attempt to hide overlay even if animation fails                if (overlayRef.value) {                    overlayRef.value.style.opacity = '0';                }            }        };        // Initialize animation when component is mounted        onMounted(() => {            try {                initAnimation();                // Initial state based on active prop                if (props.active) {                    showOverlay();                }            } catch (error) {                console.error('[TransitionOverlay] Mount error:', error);            }        });        // Clean up resources when component is unmounted        onBeforeUnmount(() => {            try {                // Kill animation and clear timeout to prevent memory leaks                if (animation) {                    animation.kill();                    animation = null;                }                if (timeoutId) {                    window.clearTimeout(timeoutId);                    timeoutId = undefined;                }            } catch (error) {                console.error('[TransitionOverlay] Unmount cleanup error:', error);            }        });        // Watch for changes to the active prop        watch(() => props.active, (isActive) => {            try {                isActive ? showOverlay() : hideOverlay();            } catch (error) {                console.error('[TransitionOverlay] Watch handler error:', error);                // Attempt direct DOM manipulation as fallback                if (overlayRef.value) {                    overlayRef.value.style.opacity = isActive ? '1' : '0';                }            }        });        return {            overlayRef        };    }});</script>


// src/components/common/ProgressBar.vue
<template>    <div class="progress-bar" :class="[        `progress-bar--${variant}`,        { 'progress-bar--animated': animated },        { 'progress-bar--labeled': showLabels },        { 'progress-bar--with-steps': isStepProgress }    ]">        <!-- Label for the progress -->        <div v-if="label" class="progress-bar__header">            <div class="progress-bar__label">{{ label }}</div>            <div class="progress-bar__percentage" v-if="showPercentage">{{ Math.round(value) }}%</div>        </div>        <!-- Main progress track -->        <div class="progress-bar__track" ref="trackRef">            <!-- Progress fill -->            <div class="progress-bar__fill" :style="fillStyle" ref="fillRef">                <!-- Visual effect for the animated edge -->                <div v-if="animated" class="progress-bar__pulse"></div>            </div>            <!-- Step markers for step-based progress -->            <div v-if="isStepProgress" class="progress-bar__steps">                <div v-for="(step, index) in steps" :key="`step-${index}`" class="progress-bar__step" :class="{                    'progress-bar__step--active': index <= completedSteps,                    'progress-bar__step--current': index === completedSteps                }" :style="{ left: `${(index / (steps.length - 1)) * 100}%` }">                    <div class="progress-bar__step-marker"></div>                    <div v-if="showLabels" class="progress-bar__step-label">                        {{ step.label }}                    </div>                </div>            </div>        </div>        <!-- Optional description text -->        <div v-if="description" class="progress-bar__description">            {{ description }}        </div>    </div></template><script lang="ts">import { defineComponent, ref, computed, watch, onMounted, PropType } from 'vue';import gsap from 'gsap';import { ANIMATION_TIMING, EASING } from '@/utils/animations';type ProgressVariant = 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';interface ProgressStep {    label: string;    value: number;    description?: string;}export default defineComponent({    name: 'ProgressBar',    props: {        value: {            type: Number,            default: 0,            validator: (val: number) => val >= 0 && val <= 100        },        variant: {            type: String as PropType<ProgressVariant>,            default: 'primary',            validator: (val: string) => ['primary', 'secondary', 'success', 'warning', 'danger', 'info'].includes(val)        },        showPercentage: {            type: Boolean,            default: true        },        label: {            type: String,            default: ''        },        description: {            type: String,            default: ''        },        animated: {            type: Boolean,            default: true        },        height: {            type: Number,            default: 8 // Default height in pixels        },        rounded: {            type: Boolean,            default: true        },        striped: {            type: Boolean,            default: false        },        // Step-based progress options        steps: {            type: Array as PropType<ProgressStep[]>,            default: () => []        },        completedSteps: {            type: Number,            default: 0        },        showLabels: {            type: Boolean,            default: true        },        // Animation options        animateChanges: {            type: Boolean,            default: true        },        animationDuration: {            type: Number,            default: ANIMATION_TIMING.STANDARD        }    },    setup(props) {        const trackRef = ref<HTMLElement | null>(null);        const fillRef = ref<HTMLElement | null>(null);        // Computed properties        const isStepProgress = computed(() => props.steps.length > 0);        const effectiveValue = computed(() => {            if (isStepProgress.value && props.completedSteps >= 0) {                // Calculate percentage based on completed steps                return props.completedSteps >= props.steps.length - 1                    ? 100                    : (props.completedSteps / (props.steps.length - 1)) * 100;            }            return Math.min(Math.max(props.value, 0), 100);        });        const fillStyle = computed(() => {            return {                width: `${effectiveValue.value}%`,                height: `${props.height}px`,                borderRadius: props.rounded ? `${props.height / 2}px` : '0'            };        });        /**         * Animate progress changes         * @param oldValue - Previous value         * @param newValue - New value         */        const animateProgress = (oldValue: number, newValue: number) => {            try {                if (!props.animateChanges || !fillRef.value) return;                gsap.fromTo(                    fillRef.value,                    { width: `${oldValue}%` },                    {                        width: `${newValue}%`,                        duration: props.animationDuration,                        ease: EASING.EASE_OUT                    }                );            } catch (error) {                console.error('[ProgressBar] Animation error:', error);                // Fallback to direct style update                if (fillRef.value) {                    fillRef.value.style.width = `${newValue}%`;                }            }        };        // Watch for value changes to animate        watch(            effectiveValue,            (newVal, oldVal) => {                if (oldVal !== newVal) {                    animateProgress(oldVal, newVal);                }            }        );        // Initialize animation on mount        onMounted(() => {            try {                // Initial animation from 0                if (props.animateChanges && effectiveValue.value > 0) {                    animateProgress(0, effectiveValue.value);                }            } catch (error) {                console.error('[ProgressBar] Mount error:', error);            }        });        return {            trackRef,            fillRef,            isStepProgress,            effectiveValue,            fillStyle        };    }});</script><style lang="scss" scoped>.progress-bar {    width: 100%;    margin: 12px 0;    // Variant colors    &--primary {        --progress-color: var(--ion-color-primary);        --progress-text: var(--ion-color-primary-contrast);    }    &--secondary {        --progress-color: var(--ion-color-secondary);        --progress-text: var(--ion-color-secondary-contrast);    }    &--success {        --progress-color: var(--ion-color-success);        --progress-text: var(--ion-color-success-contrast);    }    &--warning {        --progress-color: var(--ion-color-warning);        --progress-text: var(--ion-color-warning-contrast);    }    &--danger {        --progress-color: var(--ion-color-danger);        --progress-text: var(--ion-color-danger-contrast);    }    &--info {        --progress-color: var(--ion-color-medium);        --progress-text: var(--ion-color-medium-contrast);    }    // Header part    &__header {        display: flex;        justify-content: space-between;        align-items: center;        margin-bottom: 6px;        font-size: 14px;    }    &__label {        font-weight: 500;        color: var(--ion-text-color);    }    &__percentage {        font-weight: 600;        color: var(--progress-color);    }    // Main progress track    &__track {        position: relative;        width: 100%;        background-color: rgba(var(--ion-color-medium-rgb), 0.2);        border-radius: 4px;        overflow: hidden;    }    &__fill {        position: relative;        width: 0;        height: 8px;        /* Default height, overridden by inline style */        background-color: var(--progress-color);        transition: width 0.4s ease;        will-change: width;        // Striped effect        .progress-bar--striped & {            background-image: linear-gradient(45deg,                    rgba(255, 255, 255, 0.15) 25%,                    transparent 25%,                    transparent 50%,                    rgba(255, 255, 255, 0.15) 50%,                    rgba(255, 255, 255, 0.15) 75%,                    transparent 75%,                    transparent);            background-size: 40px 40px;        }        // Animated striped effect        .progress-bar--animated.progress-bar--striped & {            animation: progress-bar-stripes 1s linear infinite;        }    }    // Pulse effect at the edge of the progress bar    &__pulse {        position: absolute;        top: 0;        right: 0;        width: 10px;        height: 100%;        background: rgba(255, 255, 255, 0.3);        filter: blur(3px);        animation: progress-bar-pulse 1.5s ease-in-out infinite;    }    // Step markers for step progress    &__steps {        position: absolute;        top: 0;        left: 0;        width: 100%;        height: 100%;        z-index: 10;    }    &__step {        position: absolute;        transform: translateX(-50%);        &--active .progress-bar__step-marker {            background-color: var(--progress-color);            border-color: var(--progress-color);        }        &--current .progress-bar__step-marker {            box-shadow: 0 0 0 3px rgba(var(--ion-color-primary-rgb), 0.3);        }    }    &__step-marker {        width: 16px;        height: 16px;        background-color: var(--ion-color-light);        border: 2px solid var(--ion-color-medium);        border-radius: 50%;        z-index: 10;        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        transition: all 0.3s ease;    }    &__step-label {        position: absolute;        top: 100%;        left: 50%;        transform: translateX(-50%);        margin-top: 8px;        white-space: nowrap;        font-size: 12px;        color: var(--ion-text-color);        font-weight: 500;        .progress-bar__step--active & {            color: var(--progress-color);        }    }    // Extra spacing for step labels    &--with-steps {        margin-bottom: 30px;        &.progress-bar--labeled {            margin-bottom: 50px;        }    }    // Description text    &__description {        margin-top: 8px;        font-size: 12px;        color: var(--ion-color-medium);    }}@keyframes progress-bar-stripes {    from {        background-position: 40px 0;    }    to {        background-position: 0 0;    }}@keyframes progress-bar-pulse {    0% {        opacity: 0.6;        width: 4px;    }    50% {        opacity: 0.8;        width: 8px;    }    100% {        opacity: 0.6;        width: 4px;    }}</style>


// src/components/common/FileUploader.vue
<template>    <div class="file-uploader" :class="[        `file-uploader--${variant}`,        { 'file-uploader--compact': compact },        { 'file-uploader--error': !!error },        { 'file-uploader--dragover': isDragOver },        { 'file-uploader--has-file': hasFile },        { 'file-uploader--disabled': disabled },        { 'file-uploader--loading': loading }    ]">        <!-- Hidden file input element -->        <input type="file" ref="fileInput" class="file-uploader__input" :accept="acceptTypes" :multiple="multiple"            :disabled="disabled || loading" @change="handleFileChange" />        <!-- Drag and drop area -->        <div class="file-uploader__dropzone" @dragover.prevent="handleDragOver" @dragleave.prevent="handleDragLeave"            @drop.prevent="handleDrop" @click="triggerFileSelect">            <!-- Loading state with spinner -->            <div v-if="loading" class="file-uploader__loading">                <ion-spinner name="dots" />                <span class="file-uploader__loading-text">{{ loadingText }}</span>            </div>            <!-- File selection prompt (empty state) -->            <div v-else-if="!hasFile" class="file-uploader__prompt">                <div class="file-uploader__icon">                    <ion-icon :icon="uploadIcon" />                </div>                <div class="file-uploader__text">                    <div class="file-uploader__title">{{ title || 'Upload a file' }}</div>                    <div class="file-uploader__subtitle">                        {{ subtitle || `Drag and drop or click to browse` }}                    </div>                    <div v-if="acceptedTypesDisplay" class="file-uploader__accepted-types">                        {{ acceptedTypesDisplay }}                    </div>                </div>            </div>            <!-- File preview (file selected state) -->            <div v-else class="file-uploader__preview">                <!-- Image preview if file is an image -->                <div v-if="isImageFile" class="file-uploader__preview-image">                    <img :src="previewUrl" alt="Preview" class="file-uploader__image" />                </div>                <!-- Generic file icon for non-image files -->                <div v-else class="file-uploader__preview-icon">                    <ion-icon :icon="getFileIcon()" />                </div>                <!-- File information -->                <div class="file-uploader__file-info">                    <div class="file-uploader__filename">{{ fileName }}</div>                    <div class="file-uploader__filesize">{{ formattedFileSize }}</div>                </div>                <!-- Remove file button -->                <button class="file-uploader__remove-btn" @click.stop="removeFile" :disabled="disabled || loading"                    v-if="!disabled && !loading">                    <ion-icon :icon="removeIcon" />                </button>            </div>        </div>        <!-- Progress bar during upload -->        <div v-if="uploadProgress > 0 && uploadProgress < 100" class="file-uploader__progress">            <ProgressBar :value="uploadProgress" variant="primary" :height="4" :show-percentage="false" animated />        </div>        <!-- Error message -->        <div v-if="error" class="file-uploader__error-message">            {{ error }}        </div>        <!-- Optional help text -->        <div v-if="helpText && !error" class="file-uploader__help-text">            {{ helpText }}        </div>    </div></template><script lang="ts">import { defineComponent, ref, computed, PropType, watch } from 'vue';import { IonIcon, IonSpinner } from '@ionic/vue';import ProgressBar from './ProgressBar.vue';import {    cloudUploadOutline,    documentOutline,    imageOutline,    documentTextOutline,    closeCircleOutline} from 'ionicons/icons';type FileCategory = 'image' | 'document' | 'pdf' | 'spreadsheet' | 'archive' | 'code' | 'audio' | 'video' | 'other';const fileIconMap = {    image: imageOutline,    document: documentTextOutline,    pdf: documentTextOutline,    spreadsheet: documentTextOutline,    archive: documentOutline,    code: documentTextOutline,    audio: documentOutline,    video: documentOutline,    other: documentOutline};const fileExtensionMap: Record<string, FileCategory> = {    // Images    'jpg': 'image',    'jpeg': 'image',    'png': 'image',    'gif': 'image',    'svg': 'image',    'webp': 'image',    // Documents    'doc': 'document',    'docx': 'document',    'txt': 'document',    'rtf': 'document',    // PDFs    'pdf': 'pdf',    // Spreadsheets    'xls': 'spreadsheet',    'xlsx': 'spreadsheet',    'csv': 'spreadsheet',    // Archives    'zip': 'archive',    'rar': 'archive',    'tar': 'archive',    'gz': 'archive',    // Code    'html': 'code',    'css': 'code',    'js': 'code',    'ts': 'code',    'json': 'code',    // Audio    'mp3': 'audio',    'wav': 'audio',    'ogg': 'audio',    // Video    'mp4': 'video',    'webm': 'video',    'avi': 'video'};type UploaderVariant = 'primary' | 'secondary' | 'neutral';export default defineComponent({    name: 'FileUploader',    components: {        IonIcon,        IonSpinner,        ProgressBar    },    props: {        variant: {            type: String as PropType<UploaderVariant>,            default: 'primary',            validator: (val: string) => ['primary', 'secondary', 'neutral'].includes(val)        },        accept: {            type: String,            default: ''        },        multiple: {            type: Boolean,            default: false        },        maxFileSize: {            type: Number,            default: 5 // in MB        },        title: {            type: String,            default: ''        },        subtitle: {            type: String,            default: ''        },        helpText: {            type: String,            default: ''        },        compact: {            type: Boolean,            default: false        },        disabled: {            type: Boolean,            default: false        },        loading: {            type: Boolean,            default: false        },        loadingText: {            type: String,            default: 'Uploading...'        },        uploadProgress: {            type: Number,            default: 0        },        modelValue: {            type: [File, Array] as PropType<File | File[] | null>,            default: null        },        error: {            type: String,            default: ''        }    },    emits: ['update:modelValue', 'file-selected', 'file-removed', 'error'],    setup(props, { emit }) {        const fileInput = ref<HTMLInputElement | null>(null);        const isDragOver = ref<boolean>(false);        const previewUrl = ref<string>('');        // Convert accept prop to array of file extensions        const acceptTypes = computed(() => props.accept);        // Human-readable accepted types for display        const acceptedTypesDisplay = computed(() => {            if (!props.accept) return '';            const types = props.accept.split(',').map(type => {                // Extract extension from MIME type or glob pattern                const ext = type.trim();                if (ext.startsWith('.')) {                    // Already an extension                    return ext;                } else if (ext.includes('/')) {                    // MIME type like 'image/png'                    const parts = ext.split('/');                    if (parts[1] === '*') {                        return parts[0].toUpperCase();                    }                    return parts[1].toUpperCase();                }                return ext;            });            return `Accepted formats: ${types.join(', ')}`;        });        // Computed properties for file display        const hasFile = computed(() => {            if (Array.isArray(props.modelValue)) {                return props.modelValue.length > 0;            }            return !!props.modelValue;        });        const fileName = computed(() => {            if (!hasFile.value) return '';            if (Array.isArray(props.modelValue)) {                if (props.modelValue.length === 0) return '';                if (props.modelValue.length === 1) return props.modelValue[0].name;                return `${props.modelValue.length} files selected`;            }            return props.modelValue?.name || '';        });        const formattedFileSize = computed(() => {            if (!hasFile.value) return '';            let size = 0;            if (Array.isArray(props.modelValue)) {                if (props.modelValue.length === 0) return '';                size = props.modelValue.reduce((sum, file) => sum + file.size, 0);            } else if (props.modelValue) {                size = props.modelValue.size;            }            // Format size to appropriate unit            if (size < 1024) {                return `${size} B`;            } else if (size < 1024 * 1024) {                return `${(size / 1024).toFixed(1)} KB`;            } else {                return `${(size / (1024 * 1024)).toFixed(1)} MB`;            }        });        const isImageFile = computed(() => {            if (!hasFile.value) return false;            const file = Array.isArray(props.modelValue)                ? props.modelValue[0]                : props.modelValue;            if (!file) return false;            return file.type.startsWith('image/');        });        // Icon references        const uploadIcon = cloudUploadOutline;        const removeIcon = closeCircleOutline;        /**         * Get appropriate icon for file type         */        const getFileIcon = (): string => {            if (!hasFile.value) return documentOutline;            const file = Array.isArray(props.modelValue)                ? props.modelValue[0]                : props.modelValue;            if (!file) return documentOutline;            // Check if it's an image            if (file.type.startsWith('image/')) {                return imageOutline;            }            // Get file extension            const extension = file.name.split('.').pop()?.toLowerCase() || '';            const fileType = fileExtensionMap[extension] || 'other';            return fileIconMap[fileType];        };        /**         * Generate image preview for image files         */        const generatePreview = () => {            // Clear any existing preview URL            if (previewUrl.value) {                URL.revokeObjectURL(previewUrl.value);                previewUrl.value = '';            }            if (!hasFile.value) return;            const file = Array.isArray(props.modelValue)                ? props.modelValue[0]                : props.modelValue;            if (!file || !file.type.startsWith('image/')) return;            // Create object URL for preview            previewUrl.value = URL.createObjectURL(file);        };        /**         * Validate file(s) before emitting events         */        const validateFiles = (files: File | File[]): { valid: boolean; error?: string } => {            if (!files) return { valid: false, error: 'No file selected' };            const filesToCheck = Array.isArray(files) ? files : [files];            // Check if any files were selected            if (filesToCheck.length === 0) {                return { valid: false, error: 'No file selected' };            }            // Check each file's size            for (const file of filesToCheck) {                const fileSizeMB = file.size / (1024 * 1024);                if (fileSizeMB > props.maxFileSize) {                    return {                        valid: false,                        error: `File size exceeds the ${props.maxFileSize}MB limit`                    };                }            }            // Check file type if accept prop is provided            if (props.accept) {                const acceptedTypes = props.accept.split(',').map(type => type.trim());                for (const file of filesToCheck) {                    let isAccepted = false;                    for (const acceptType of acceptedTypes) {                        // Check for MIME type match                        if (acceptType.includes('/')) {                            // Full MIME type (e.g., image/png) or wildcard (e.g., image/*)                            const [category, subtype] = acceptType.split('/');                            if (subtype === '*') {                                // Category wildcard (e.g., image/*)                                if (file.type.startsWith(`${category}/`)) {                                    isAccepted = true;                                    break;                                }                            } else if (file.type === acceptType) {                                // Exact match                                isAccepted = true;                                break;                            }                        }                        // Check for extension match                        else if (acceptType.startsWith('.')) {                            const extension = `.${file.name.split('.').pop()?.toLowerCase()}`;                            if (extension === acceptType.toLowerCase()) {                                isAccepted = true;                                break;                            }                        }                    }                    if (!isAccepted) {                        return {                            valid: false,                            error: `Invalid file type. Please upload ${acceptedTypesDisplay.value.toLowerCase()}`                        };                    }                }            }            return { valid: true };        };        /**         * Handle drag over event         */        const handleDragOver = (event: DragEvent) => {            if (props.disabled || props.loading) return;            isDragOver.value = true;            // Check if files are being dragged            if (event.dataTransfer) {                event.dataTransfer.dropEffect = 'copy';            }        };        /**         * Handle drag leave event         */        const handleDragLeave = () => {            isDragOver.value = false;        };        /**         * Handle drop event         */        const handleDrop = (event: DragEvent) => {            if (props.disabled || props.loading) return;            isDragOver.value = false;            if (!event.dataTransfer || !event.dataTransfer.files.length) return;            const droppedFiles = event.dataTransfer.files;            if (props.multiple) {                const filesArray = Array.from(droppedFiles);                const validation = validateFiles(filesArray);                if (validation.valid) {                    emit('update:modelValue', filesArray);                    emit('file-selected', filesArray);                } else if (validation.error) {                    emit('error', validation.error);                }            } else {                // Take only the first file when multiple is false                const file = droppedFiles[0];                const validation = validateFiles(file);                if (validation.valid) {                    emit('update:modelValue', file);                    emit('file-selected', file);                } else if (validation.error) {                    emit('error', validation.error);                }            }        };        /**         * Trigger file input click         */        const triggerFileSelect = () => {            if (props.disabled || props.loading) return;            fileInput.value?.click();        };        /**         * Handle file input change         */        const handleFileChange = (event: Event) => {            const input = event.target as HTMLInputElement;            if (!input.files || input.files.length === 0) return;            if (props.multiple) {                const filesArray = Array.from(input.files);                const validation = validateFiles(filesArray);                if (validation.valid) {                    emit('update:modelValue', filesArray);                    emit('file-selected', filesArray);                } else if (validation.error) {                    emit('error', validation.error);                    input.value = ''; // Clear the input                }            } else {                // Take only the first file when multiple is false                const file = input.files[0];                const validation = validateFiles(file);                if (validation.valid) {                    emit('update:modelValue', file);                    emit('file-selected', file);                } else if (validation.error) {                    emit('error', validation.error);                    input.value = ''; // Clear the input                }            }        };        /**         * Remove selected file(s)         */        const removeFile = (event: Event) => {            event.stopPropagation();            if (props.disabled || props.loading) return;            if (fileInput.value) {                fileInput.value.value = '';            }            // Clear preview URL if any            if (previewUrl.value) {                URL.revokeObjectURL(previewUrl.value);                previewUrl.value = '';            }            emit('update:modelValue', props.multiple ? [] : null);            emit('file-removed');        };        // Update preview when model value changes        watch(() => props.modelValue, generatePreview, { immediate: true });        // Clean up resources when component is destroyed        watch(() => previewUrl.value, (url, oldUrl) => {            if (oldUrl && oldUrl !== url) {                URL.revokeObjectURL(oldUrl);            }        });        return {            fileInput,            isDragOver,            previewUrl,            acceptTypes,            acceptedTypesDisplay,            hasFile,            fileName,            formattedFileSize,            isImageFile,            uploadIcon,            removeIcon,            getFileIcon,            handleDragOver,            handleDragLeave,            handleDrop,            triggerFileSelect,            handleFileChange,            removeFile        };    }});</script><style lang="scss" scoped>.file-uploader {    width: 100%;    border-radius: 8px;    margin-bottom: 16px;    // Hide the actual file input    &__input {        position: absolute;        width: 1px;        height: 1px;        opacity: 0;        overflow: hidden;        z-index: -1;    }    // Color variants    &--primary {        --uploader-border-color: rgba(var(--ion-color-primary-rgb), 0.3);        --uploader-bg-color: rgba(var(--ion-color-primary-rgb), 0.05);        --uploader-accent-color: var(--ion-color-primary);        --uploader-text-color: var(--ion-color-dark);        --uploader-icon-color: var(--ion-color-primary);    }    &--secondary {        --uploader-border-color: rgba(var(--ion-color-secondary-rgb), 0.3);        --uploader-bg-color: rgba(var(--ion-color-secondary-rgb), 0.05);        --uploader-accent-color: var(--ion-color-secondary);        --uploader-text-color: var(--ion-color-dark);        --uploader-icon-color: var(--ion-color-secondary);    }    &--neutral {        --uploader-border-color: rgba(var(--ion-color-medium-rgb), 0.3);        --uploader-bg-color: rgba(var(--ion-color-medium-rgb), 0.05);        --uploader-accent-color: var(--ion-color-medium);        --uploader-text-color: var(--ion-color-dark);        --uploader-icon-color: var(--ion-color-medium);    }    // Error state    &--error {        --uploader-border-color: rgba(var(--ion-color-danger-rgb), 0.3);        --uploader-bg-color: rgba(var(--ion-color-danger-rgb), 0.05);        --uploader-accent-color: var(--ion-color-danger);        --uploader-icon-color: var(--ion-color-danger);    }    // Dropzone area    &__dropzone {        border: 2px dashed var(--uploader-border-color);        border-radius: 8px;        background-color: var(--uploader-bg-color);        padding: 24px;        text-align: center;        cursor: pointer;        transition: all 0.3s ease;        position: relative;        overflow: hidden;        .file-uploader--compact & {            padding: 16px;        }        .file-uploader--dragover & {            border-color: var(--uploader-accent-color);            background-color: rgba(var(--ion-color-primary-rgb), 0.1);            transform: scale(1.02);        }        .file-uploader--has-file & {            border-style: solid;            background-color: var(--uploader-bg-color);        }        .file-uploader--disabled & {            opacity: 0.6;            cursor: not-allowed;        }    }    // Empty state prompt    &__prompt {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;    }    &__icon {        font-size: 36px;        color: var(--uploader-icon-color);        margin-bottom: 16px;        .file-uploader--compact & {            font-size: 28px;            margin-bottom: 12px;        }    }    &__text {        max-width: 240px;        margin: 0 auto;    }    &__title {        font-size: 16px;        font-weight: 600;        color: var(--uploader-text-color);        margin-bottom: 8px;        .file-uploader--compact & {            font-size: 14px;            margin-bottom: 4px;        }    }    &__subtitle {        font-size: 14px;        color: var(--ion-color-medium);        margin-bottom: 8px;        .file-uploader--compact & {            font-size: 12px;            margin-bottom: 4px;        }    }    &__accepted-types {        font-size: 12px;        color: var(--ion-color-medium);        opacity: 0.8;        .file-uploader--compact & {            font-size: 10px;        }    }    // File preview state    &__preview {        display: flex;        align-items: center;        text-align: left;    }    &__preview-image {        width: 60px;        height: 60px;        margin-right: 16px;        border-radius: 4px;        overflow: hidden;        flex-shrink: 0;    }    &__image {        width: 100%;        height: 100%;        object-fit: cover;    }    &__preview-icon {        width: 60px;        height: 60px;        display: flex;        align-items: center;        justify-content: center;        margin-right: 16px;        background-color: rgba(var(--ion-color-light-rgb), 0.5);        border-radius: 4px;        flex-shrink: 0;        ion-icon {            font-size: 30px;            color: var(--uploader-icon-color);        }    }    &__file-info {        flex-grow: 1;        min-width: 0; // Enable text truncation    }    &__filename {        font-weight: 600;        font-size: 16px;        color: var(--uploader-text-color);        margin-bottom: 4px;        white-space: nowrap;        overflow: hidden;        text-overflow: ellipsis;    }    &__filesize {        font-size: 14px;        color: var(--ion-color-medium);    }    &__remove-btn {        background: none;        border: none;        color: var(--ion-color-medium);        font-size: 24px;        cursor: pointer;        padding: 8px;        margin: -8px;        border-radius: 50%;        display: flex;        align-items: center;        justify-content: center;        transition: all 0.2s ease;        &:hover {            color: var(--ion-color-danger);            background-color: rgba(var(--ion-color-danger-rgb), 0.1);        }        &:focus {            outline: none;        }    }    // Loading state    &__loading {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;        ion-spinner {            margin-bottom: 8px;            color: var(--uploader-accent-color);        }    }    &__loading-text {        font-size: 14px;        color: var(--ion-color-medium);    }    // Progress bar    &__progress {        margin-top: 8px;    }    // Error message    &__error-message {        margin-top: 8px;        font-size: 12px;        color: var(--ion-color-danger);    }    // Help text    &__help-text {        margin-top: 8px;        font-size: 12px;        color: var(--ion-color-medium);    }}</style>


// src/components/common/AnimatedBackground.vue
<style lang="scss" scoped>.animated-background {    position: relative;    width: 100%;    height: 100%;    overflow: hidden;    z-index: 0;    // Variant-specific styles    &--primary {        background: var(--ion-color-primary);        --element-color: rgba(255, 255, 255, 0.2);    }    &--secondary {        background: var(--ion-color-secondary);        --element-color: rgba(255, 255, 255, 0.2);    }    &--dark {        background: var(--ion-color-dark);        --element-color: rgba(255, 255, 255, 0.15);    }    &--light {        background: var(--ion-color-light);        --element-color: rgba(0, 0, 0, 0.1);    }    &--gradient {        background: linear-gradient(135deg, var(--ion-color-primary), var(--ion-color-secondary));        --element-color: rgba(255, 255, 255, 0.2);    }    // Floating elements    &__element {        position: absolute;        border-radius: 50%; // Default for circles and dots        will-change: transform, opacity;        &--circle {            background-color: var(--element-color);            border-radius: 50%;        }        &--square {            background-color: var(--element-color);            border-radius: 4px;        }        &--triangle {            // Style is set dynamically in the component            // Uses border technique for triangles        }        &--dot {            background-color: var(--element-color);            border-radius: 50%;            transform: scale(0.5); // Smaller than regular circles        }    }    // Wave overlay    &__waves {        position: absolute;        bottom: 0;        left: 0;        width: 100%;        height: 40%;        overflow: hidden;    }    &__wave {        position: absolute;        width: 140%;        height: 100%;        background-repeat: repeat-x;        background-position: 0 bottom;        transform-origin: center bottom;        &--1 {            bottom: 0;            height: 5%;            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none"><path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z" opacity=".25" fill="%23FFFFFF" /></svg>');            opacity: 0.3;        }        &--2 {            bottom: 0;            height: 10%;            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none"><path d="M321.39,56.44c58-10.79,114.16-30.13,172-41.86,82.39-16.72,168.19-17.73,250.45-.39C823.78,31,906.67,72,985.66,92.83c70.05,18.48,146.53,26.09,214.34,3V0H0V27.35A600.21,600.21,0,0,0,321.39,56.44Z" opacity=".25" fill="%23FFFFFF" /></svg>');            opacity: 0.2;            z-index: 1;        }        &--3 {            bottom: 0;            height: 15%;            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120" preserveAspectRatio="none"><path d="M0,0V7.23C0,65.52,268.63,112.77,600,112.77S1200,65.52,1200,7.23V0Z" opacity=".25" fill="%23FFFFFF" /></svg>');            opacity: 0.1;            z-index: 2;        }    }    // Gradient overlay    &__gradient {        position: absolute;        top: 0;        left: 0;        width: 100%;        height: 100%;        z-index: 3;        pointer-events: none;        &--primary {            background: radial-gradient(circle at 50% 10%, rgba(var(--ion-color-primary-rgb), 0) 0%, rgba(var(--ion-color-primary-rgb), 0.8) 100%);        }        &--secondary {            background: radial-gradient(circle at 50% 10%, rgba(var(--ion-color-secondary-rgb), 0) 0%, rgba(var(--ion-color-secondary-rgb), 0.8) 100%);        }        &--dark {            background: radial-gradient(circle at 50% 10%, rgba(var(--ion-color-dark-rgb), 0) 0%, rgba(var(--ion-color-dark-rgb), 0.8) 100%);        }        &--light {            background: radial-gradient(circle at 50% 10%, rgba(var(--ion-color-light-rgb), 0) 0%, rgba(var(--ion-color-light-rgb), 0.8) 100%);        }        &--gradient {            background: radial-gradient(circle at 50% 10%, transparent 0%, rgba(0, 0, 0, 0.2) 100%);        }    }    // Content slot    &__content {        position: relative;        z-index: 5;        height: 100%;        width: 100%;    }}</style><template>    <div class="animated-background" :class="[`animated-background--${variant}`]" ref="backgroundRef">        <!-- Floating elements -->        <div v-for="(element, index) in floatingElements" :key="`floating-element-${index}`"            class="animated-background__element" :class="[`animated-background__element--${element.type}`]"            :style="element.style" ref="elementsRef"></div>        <!-- Wave overlay -->        <div class="animated-background__waves">            <div class="animated-background__wave animated-background__wave--1"></div>            <div class="animated-background__wave animated-background__wave--2"></div>            <div class="animated-background__wave animated-background__wave--3"></div>        </div>        <!-- Gradient overlay -->        <div class="animated-background__gradient" :class="[`animated-background__gradient--${variant}`]"></div>        <!-- Content slot -->        <div class="animated-background__content">            <slot></slot>        </div>    </div></template><script lang="ts">import { defineComponent, ref, onMounted, onBeforeUnmount, PropType, watch } from 'vue';import gsap from 'gsap';import { ANIMATION_TIMING, EASING, animationController } from '@/utils/animations';type BackgroundVariant = 'primary' | 'secondary' | 'dark' | 'light' | 'gradient';type ElementType = 'circle' | 'square' | 'triangle' | 'dot';interface FloatingElement {    type: ElementType;    size: number;    x: number;    y: number;    opacity: number;    rotation: number;    delay: number;    duration: number;    style: Record<string, string>;}export default defineComponent({    name: 'AnimatedBackground',    props: {        variant: {            type: String as PropType<BackgroundVariant>,            default: 'primary',            validator: (value: string) => {                return ['primary', 'secondary', 'dark', 'light', 'gradient'].includes(value);            }        },        elementCount: {            type: Number,            default: 15,            validator: (value: number) => {                return value >= 0 && value <= 50;            }        },        animated: {            type: Boolean,            default: true        },        interactive: {            type: Boolean,            default: true        },        density: {            type: Number,            default: 1,            validator: (value: number) => {                return value >= 0.1 && value <= 2;            }        }    },    setup(props) {        const backgroundRef = ref<HTMLElement | null>(null);        const elementsRef = ref<HTMLElement[]>([]);        const floatingElements = ref<FloatingElement[]>([]);        // Animation IDs for cleanup        const animationIds = {            elements: 'background-elements',            waves: 'background-waves',            mouse: 'background-mouse'        };        // Interactive mouse tracking        const mousePosition = {            x: 0,            y: 0,            moving: false        };        /**    * Generate random floating elements based on props    */        const generateElements = () => {            try {                const elements: FloatingElement[] = [];                const count = Math.min(Math.max(props.elementCount, 0), 50);                // Element type distribution                const typeDistribution = [                    { type: 'circle', weight: 0.4 },                    { type: 'square', weight: 0.25 },                    { type: 'triangle', weight: 0.15 },                    { type: 'dot', weight: 0.2 }                ];                for (let i = 0; i < count; i++) {                    // Randomly select element type based on distribution                    const randomValue = Math.random();                    let cumulativeWeight = 0;                    let selectedType: ElementType = 'circle';                    for (const { type, weight } of typeDistribution) {                        cumulativeWeight += weight;                        if (randomValue <= cumulativeWeight) {                            selectedType = type as ElementType;                            break;                        }                    }                    // Randomize properties with constraints                    const size = Math.floor(Math.random() * 40) + 10; // 10-50px                    const x = Math.random() * 100; // 0-100%                    const y = Math.random() * 100; // 0-100%                    const opacity = (Math.random() * 0.5) + 0.1; // 0.1-0.6                    const rotation = Math.floor(Math.random() * 360); // 0-360deg                    const delay = Math.random() * 5; // 0-5s                    const duration = (Math.random() * 20) + 15; // 15-35s                    // Calculate z-index based on size for parallax effect                    const zIndex = Math.floor((1 - (size / 50)) * 5);                    // Generate element styles                    const style: Record<string, string> = {                        width: `${size}px`,                        height: `${size}px`,                        left: `${x}%`,                        top: `${y}%`,                        opacity: opacity.toString(),                        transform: `rotate(${rotation}deg)`,                        zIndex: zIndex.toString()                    };                    // For triangle, we need different dimensions                    if (selectedType === 'triangle') {                        style.width = '0';                        style.height = '0';                        style.borderLeft = `${size / 2}px solid transparent`;                        style.borderRight = `${size / 2}px solid transparent`;                        style.borderBottom = `${size}px solid var(--element-color)`;                    }                    elements.push({                        type: selectedType,                        size,                        x,                        y,                        opacity,                        rotation,                        delay,                        duration,                        style                    });                }                floatingElements.value = elements;            } catch (error) {                console.error('[AnimatedBackground] Element generation error:', error);                // Fallback to empty array on error                floatingElements.value = [];            }        };        /**         * Initialize animations for floating elements         */        const initElementAnimations = () => {            try {                if (!props.animated || elementsRef.value.length === 0) return;                // Kill existing animations                animationController.remove(animationIds.elements);                // Create master timeline                const master = gsap.timeline({                    paused: true,                    repeat: -1,                    repeatDelay: 0.5                });                // Animate each element individually                elementsRef.value.forEach((el, index) => {                    if (index >= floatingElements.value.length) return;                    const element = floatingElements.value[index];                    const delay = element.delay;                    const duration = element.duration;                    // Create random movement and rotation animation                    const tl = gsap.timeline({ repeat: -1, yoyo: true });                    // Random target position within constraints                    const xMovement = Math.random() * 20 - 10; // -10% to +10%                    const yMovement = Math.random() * 20 - 10; // -10% to +10%                    // Animated properties                    tl.to(el, {                        x: `${xMovement}%`,                        y: `${yMovement}%`,                        rotation: `+=${Math.random() > 0.5 ? 90 : -90}`,                        opacity: (Math.random() * 0.3) + 0.2,                        duration,                        ease: EASING.EASE_IN_OUT,                        delay                    });                    // Add to master timeline                    master.add(tl, 0);                });                // Register with animation controller                animationController.register(animationIds.elements, master);                // Play animation                animationController.play(animationIds.elements);            } catch (error) {                console.error('[AnimatedBackground] Element animation initialization error:', error);            }        };        /**         * Initialize wave animations         */        const initWaveAnimations = () => {            try {                if (!props.animated || !backgroundRef.value) return;                // Kill existing animations                animationController.remove(animationIds.waves);                // Select wave elements                const waves = backgroundRef.value.querySelectorAll('.animated-background__wave');                if (waves.length === 0) return;                // Create master timeline                const master = gsap.timeline({                    paused: true,                    repeat: -1,                    repeatDelay: 0                });                // Animate each wave with different parameters                waves.forEach((wave, index) => {                    const duration = 7 + (index * 1.5); // Increasing duration for each wave                    const delay = index * 0.5; // Staggered start                    const tl = gsap.timeline({ repeat: -1, yoyo: true });                    tl.to(wave, {                        x: '-20%',                        duration,                        ease: EASING.EASE_IN_OUT,                        delay                    });                    master.add(tl, 0);                });                // Register with animation controller                animationController.register(animationIds.waves, master);                // Play animation                animationController.play(animationIds.waves);            } catch (error) {                console.error('[AnimatedBackground] Wave animation initialization error:', error);            }        };        /**         * Initialize interactive mouse movement         */        const initMouseInteraction = () => {            try {                if (!props.interactive || !backgroundRef.value) return;                // Kill existing animations                animationController.remove(animationIds.mouse);                // Mouse move handler                const handleMouseMove = (e: MouseEvent) => {                    // Get container position                    const rect = backgroundRef.value?.getBoundingClientRect();                    if (!rect) return;                    // Calculate relative position (0-1)                    const x = (e.clientX - rect.left) / rect.width;                    const y = (e.clientY - rect.top) / rect.height;                    // Update stored position                    mousePosition.x = x;                    mousePosition.y = y;                    mousePosition.moving = true;                    // Apply parallax effect to elements                    updateElementsParallax();                };                // Add event listener                backgroundRef.value.addEventListener('mousemove', handleMouseMove);                // Store the removal function for cleanup                const removeListener = () => {                    backgroundRef.value?.removeEventListener('mousemove', handleMouseMove);                };                // Register dummy timeline to store cleanup                const dummy = gsap.timeline({                    paused: true,                    onComplete: removeListener                });                // Register with animation controller                animationController.register(animationIds.mouse, dummy);            } catch (error) {                console.error('[AnimatedBackground] Mouse interaction initialization error:', error);            }        };        /**         * Update elements position based on mouse position         */        const updateElementsParallax = () => {            try {                if (!mousePosition.moving || elementsRef.value.length === 0) return;                // Calculate center offset                const offsetX = (mousePosition.x - 0.5) * 2; // -1 to 1                const offsetY = (mousePosition.y - 0.5) * 2; // -1 to 1                // Apply different movement amounts based on z-index for parallax                elementsRef.value.forEach((el, index) => {                    if (index >= floatingElements.value.length) return;                    const element = floatingElements.value[index];                    const parallaxAmount = 1 - (element.size / 60); // Smaller elements move more                    const moveX = offsetX * 20 * parallaxAmount * props.density;                    const moveY = offsetY * 20 * parallaxAmount * props.density;                    // Apply with GSAP for smooth movement                    gsap.to(el, {                        x: `${moveX}px`,                        y: `${moveY}px`,                        rotation: `${element.rotation + (offsetX * 10)}deg`,                        duration: 1,                        ease: EASING.EASE_OUT                    });                });            } catch (error) {                console.error('[AnimatedBackground] Parallax update error:', error);            }        };        /**         * Initialize all animations         */        const initAnimations = () => {            try {                // Wait for next tick to ensure refs are populated                setTimeout(() => {                    initElementAnimations();                    initWaveAnimations();                    initMouseInteraction();                }, 0);            } catch (error) {                console.error('[AnimatedBackground] Animation initialization error:', error);            }        };        /**         * Cleanup all animations         */        const cleanupAnimations = () => {            try {                animationController.remove(animationIds.elements);                animationController.remove(animationIds.waves);                animationController.remove(animationIds.mouse);            } catch (error) {                console.error('[AnimatedBackground] Animation cleanup error:', error);            }        };        // Generate elements on component creation        generateElements();        // Initialize animations when component is mounted        onMounted(() => {            initAnimations();        });        // Clean up animations when component is unmounted        onBeforeUnmount(() => {            cleanupAnimations();        });        // Watch for property changes        watch(            [                () => props.animated,                () => props.interactive,                () => props.elementCount,                () => props.density            ],            () => {                // Clean up existing animations                cleanupAnimations();                // Regenerate elements if count changed                if (props.elementCount !== floatingElements.value.length) {                    generateElements();                }                // Reinitialize animations                initAnimations();            }        );        return {            backgroundRef,            elementsRef,            floatingElements        };    }});</script>


// src/vite-env.d.ts



// src/views/LandingPage.vue
<template>    <ion-page>        <ion-header class="ion-no-border" translucent>            <ion-toolbar>                <div class="landing-header">                    <div class="landing-logo">                        <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                        <span class="logo-text">JobMatch</span>                    </div>                    <ion-buttons slot="end" class="landing-nav">                        <a href="#features" class="nav-link">Features</a>                        <a href="#how-it-works" class="nav-link">How It Works</a>                        <a href="#testimonials" class="nav-link">Testimonials</a>                        <app-button size="small" variant="secondary" @click="navigateToLogin">                            Log In                        </app-button>                    </ion-buttons>                    <!-- Mobile menu button -->                    <ion-button fill="clear" class="menu-button d-md-none" @click="toggleMobileMenu">                        <ion-icon :icon="menuIcon" slot="icon-only"></ion-icon>                    </ion-button>                </div>            </ion-toolbar>        </ion-header>        <!-- Mobile menu drawer -->        <div class="mobile-menu-overlay" :class="{ 'is-active': mobileMenuOpen }" @click="closeMobileMenu"></div>        <div class="mobile-menu" :class="{ 'is-active': mobileMenuOpen }">            <div class="mobile-menu__header">                <div class="landing-logo">                    <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                    <span class="logo-text">JobMatch</span>                </div>                <ion-button fill="clear" @click="closeMobileMenu">                    <ion-icon :icon="closeIcon" slot="icon-only"></ion-icon>                </ion-button>            </div>            <div class="mobile-menu__links">                <a href="#features" class="mobile-nav-link" @click="closeMobileMenu">Features</a>                <a href="#how-it-works" class="mobile-nav-link" @click="closeMobileMenu">How It Works</a>                <a href="#testimonials" class="mobile-nav-link" @click="closeMobileMenu">Testimonials</a>                <app-button class="mt-lg" block variant="secondary" @click="navigateToLogin">                    Log In                </app-button>                <app-button class="mt-md" block @click="navigateToRegister">                    Create Account                </app-button>            </div>        </div>        <ion-content fullscreen>            <!-- Hero Section -->            <section class="hero-section" id="hero">                <animated-background variant="gradient">                    <div class="content-container hero-content">                        <div class="hero-text animate-slide-in-left">                            <h1 class="hero-title">Find Your Dream Job with Confidence</h1>                            <p class="hero-subtitle">                                Know exactly where you stand in the hiring process.                                No more waiting in uncertainty - get real-time updates on your application.                            </p>                            <div class="hero-cta">                                <app-button size="large" @click="navigateToRegister" leftIcon="person-add-outline">                                    Create Your Profile                                </app-button>                                <app-button size="large" variant="light" @click="scrollToSection('how-it-works')"                                    leftIcon="information-circle-outline">                                    How It Works                                </app-button>                            </div>                        </div>                        <div class="hero-image animate-fade-in animation-delay-300">                            <img src="@/assets/images/hero-placeholder.png"                                alt="Job candidate looking at a transparent hiring process dashboard with application status tracking, upcoming interview calendar, and real-time notification features. Shows a professional person feeling confident about their job application journey." />                        </div>                    </div>                </animated-background>            </section>            <!-- Stats Section -->            <section class="stats-section animate-fade-in">                <div class="content-container">                    <div class="stats-grid">                        <div class="stat-card">                            <div class="stat-number">2,500+</div>                            <div class="stat-label">Companies</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">50,000+</div>                            <div class="stat-label">Candidates</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">85%</div>                            <div class="stat-label">Interview Rate</div>                        </div>                        <div class="stat-card">                            <div class="stat-number">30%</div>                            <div class="stat-label">Faster Hiring</div>                        </div>                    </div>                </div>            </section>            <!-- Features Section -->            <section class="features-section" id="features">                <div class="content-container">                    <div class="section-header stagger-children stagger-fade-in">                        <h2 class="section-title">Features Designed for You</h2>                        <p class="section-subtitle">                            Our platform offers transparency and control throughout your job application journey                        </p>                    </div>                    <div class="features-grid">                        <feature-card title="Real-time Status Updates"                            description="Always know where you stand in the application process with instant notifications."                            icon="time-outline" />                        <feature-card title="Interview Scheduling"                            description="Schedule interviews directly in the platform and receive reminders."                            icon="calendar-outline" />                        <feature-card title="Document Management"                            description="Upload and manage your CV, portfolio, and other documents in one place."                            icon="document-text-outline" />                        <feature-card title="Feedback Collection"                            description="Receive constructive feedback from recruiters to improve your profile."                            icon="chatbubble-outline" />                        <feature-card title="Application Timeline"                            description="Visualize your application journey and upcoming steps in an interactive timeline."                            icon="analytics-outline" />                        <feature-card title="Direct Messaging"                            description="Communicate directly with recruiters to clarify questions and details."                            icon="mail-outline" />                    </div>                </div>            </section>            <!-- How It Works -->            <section class="how-it-works-section" id="how-it-works">                <div class="content-container">                    <div class="section-header">                        <h2 class="section-title">How It Works</h2>                        <p class="section-subtitle">                            Four simple steps to finding your perfect job match                        </p>                    </div>                    <div class="steps-container">                        <div class="step-card" v-for="(step, index) in steps" :key="`step-${index}`">                            <div class="step-number">{{ index + 1 }}</div>                            <div class="step-content">                                <h3 class="step-title">{{ step.title }}</h3>                                <p class="step-description">{{ step.description }}</p>                            </div>                            <div class="step-icon">                                <ion-icon :icon="step.icon"></ion-icon>                            </div>                        </div>                        <div class="step-connector"></div>                    </div>                </div>            </section>            <!-- Testimonials Section -->            <section class="testimonials-section" id="testimonials">                <div class="content-container">                    <div class="section-header">                        <h2 class="section-title">What Our Users Say</h2>                        <p class="section-subtitle">                            Success stories from candidates who found their dream jobs                        </p>                    </div>                    <testimonial-slider :testimonials="testimonials" />                </div>            </section>            <!-- CTA Section -->            <section class="cta-section">                <animated-background variant="primary" :element-count="8">                    <div class="content-container">                        <div class="cta-content">                            <h2 class="cta-title">Ready to take control of your job search?</h2>                            <p class="cta-subtitle">                                Create your profile today and experience a transparent hiring process.                            </p>                            <app-button size="large" variant="light" @click="navigateToRegister">                                Get Started Now                            </app-button>                        </div>                    </div>                </animated-background>            </section>            <!-- Footer -->            <footer class="landing-footer">                <div class="content-container">                    <div class="footer-grid">                        <div class="footer-brand">                            <div class="landing-logo">                                <img src="@/assets/images/logo.svg" alt="Logo" class="logo-image" />                                <span class="logo-text">JobMatch</span>                            </div>                            <p class="footer-tagline">                                Connecting talented candidates with great opportunities.                            </p>                            <div class="social-links">                                <a href="#" class="social-link">                                    <ion-icon name="logo-linkedin"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-twitter"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-facebook"></ion-icon>                                </a>                                <a href="#" class="social-link">                                    <ion-icon name="logo-instagram"></ion-icon>                                </a>                            </div>                        </div>                        <div class="footer-links">                            <div class="footer-link-group">                                <h4 class="footer-link-title">Platform</h4>                                <a href="#features" class="footer-link">Features</a>                                <a href="#how-it-works" class="footer-link">How It Works</a>                                <a href="#testimonials" class="footer-link">Testimonials</a>                                <a href="#" class="footer-link">Pricing</a>                            </div>                            <div class="footer-link-group">                                <h4 class="footer-link-title">Company</h4>                                <a href="#" class="footer-link">About Us</a>                                <a href="#" class="footer-link">Careers</a>                                <a href="#" class="footer-link">Blog</a>                                <a href="#" class="footer-link">Press</a>                            </div>                            <div class="footer-link-group">                                <h4 class="footer-link-title">Resources</h4>                                <a href="#" class="footer-link">Support</a>                                <a href="#" class="footer-link">Contact</a>                                <a href="#" class="footer-link">Privacy Policy</a>                                <a href="#" class="footer-link">Terms of Service</a>                            </div>                        </div>                    </div>                    <div class="footer-bottom">                        <p class="copyright">Â© 2023 JobMatch. All rights reserved.</p>                        <div class="footer-legal">                            <a href="#" class="legal-link">Privacy Policy</a>                            <a href="#" class="legal-link">Terms of Service</a>                            <a href="#" class="legal-link">Cookie Policy</a>                        </div>                    </div>                </div>            </footer>        </ion-content>    </ion-page></template><script lang="ts">import { defineComponent, ref } from 'vue';import { IonPage, IonHeader, IonToolbar, IonContent, IonButtons, IonButton, IonIcon } from '@ionic/vue';import { useRouter } from 'vue-router';import {    menuOutline,    closeOutline,    timeOutline,    calendarOutline,    documentTextOutline,    chatbubbleOutline,    analyticsOutline,    mailOutline,    personOutline,    briefcaseOutline,    checkmarkCircleOutline,    rocketOutline} from 'ionicons/icons';import AppButton from '@/components/common/Button.vue';import AnimatedBackground from '@/components/common/AnimatedBackground.vue';import FeatureCard from '@/components/landing/FeatureCard.vue';import TestimonialSlider from '@/components/landing/TestimonialSlider.vue';export default defineComponent({    name: 'LandingPage',    components: {        IonPage,        IonHeader,        IonToolbar,        IonContent,        IonButtons,        IonButton,        IonIcon,        AppButton,        AnimatedBackground,        FeatureCard,        TestimonialSlider    },    setup() {        const router = useRouter();        const mobileMenuOpen = ref(false);        // Step data        const steps = [            {                title: 'Create Your Profile',                description: 'Sign up and build your professional profile with your skills, experience, and job preferences.',                icon: personOutline            },            {                title: 'Apply to Jobs',                description: 'Browse available positions that match your skills and apply with just a few clicks.',                icon: briefcaseOutline            },            {                title: 'Track Your Progress',                description: 'Get real-time updates on your application status and upcoming interviews.',                icon: checkmarkCircleOutline            },            {                title: 'Land Your Dream Job',                description: 'Receive offers and accept the position that best fits your career goals.',                icon: rocketOutline            }        ];        // Testimonial data        const testimonials = [            {                id: 1,                name: 'Sarah Johnson',                position: 'Software Developer',                company: 'TechCorp',                image: '@/assets/images/testimonials/testimonial-1.jpg',                quote: 'The transparency of the platform was a game-changer for me. I could see exactly where I was in the hiring process, which eliminated the anxiety of waiting for feedback.',                rating: 5            },            {                id: 2,                name: 'Michael Chen',                position: 'Marketing Manager',                company: 'Brandify',                image: '@/assets/images/testimonials/testimonial-2.jpg',                quote: 'I love how I can schedule interviews directly through the platform. The reminders helped me prepare properly and I ended up getting the job!',                rating: 5            },            {                id: 3,                name: 'Elena Rodriguez',                position: 'UX Designer',                company: 'DesignHub',                image: '@/assets/images/testimonials/testimonial-3.jpg',                quote: 'The feedback I received through JobMatch was invaluable. I could improve my portfolio based on real recruiter comments, which ultimately led to multiple job offers.',                rating: 4            }        ];        // Navigation methods        const navigateToLogin = () => {            router.push('/login');        };        const navigateToRegister = () => {            router.push('/register');        };        // Mobile menu toggle        const toggleMobileMenu = () => {            mobileMenuOpen.value = !mobileMenuOpen.value;            if (mobileMenuOpen.value) {                document.body.classList.add('menu-open');            } else {                document.body.classList.remove('menu-open');            }        };        const closeMobileMenu = () => {            mobileMenuOpen.value = false;            document.body.classList.remove('menu-open');        };        // Smooth scroll to section        const scrollToSection = (sectionId: string) => {            const section = document.getElementById(sectionId);            if (section) {                section.scrollIntoView({ behavior: 'smooth' });            }            closeMobileMenu();        };        return {            mobileMenuOpen,            steps,            testimonials,            menuIcon: menuOutline,            closeIcon: closeOutline,            navigateToLogin,            navigateToRegister,            toggleMobileMenu,            closeMobileMenu,            scrollToSection        };    }});</script><style lang="scss" scoped>@import '@/assets/scss/variables.scss';.landing-header {    display: flex;    align-items: center;    justify-content: space-between;    width: 100%;    padding: $spacing-xs $spacing-md;}.landing-logo {    display: flex;    align-items: center;    .logo-image {        height: 32px;        width: auto;        margin-right: $spacing-xs;    }    .logo-text {        font-size: 1.25rem;        font-weight: $font-weight-bold;        color: var(--ion-color-dark);    }}.landing-nav {    display: none;    @media (min-width: $breakpoint-md) {        display: flex;        align-items: center;    }    .nav-link {        margin-right: $spacing-lg;        font-size: 1rem;        font-weight: $font-weight-medium;        color: var(--ion-color-dark);        text-decoration: none;        transition: color $transition-fast;        &:hover {            color: var(--ion-color-primary);            text-decoration: none;        }    }}.menu-button {    font-size: 1.5rem;}.mobile-menu-overlay {    position: fixed;    top: 0;    left: 0;    right: 0;    bottom: 0;    background-color: rgba(0, 0, 0, 0.5);    z-index: $z-index-modal-backdrop;    opacity: 0;    visibility: hidden;    transition: opacity 0.3s ease, visibility 0.3s ease;    &.is-active {        opacity: 1;        visibility: visible;    }}.mobile-menu {    position: fixed;    top: 0;    right: 0;    width: 80%;    max-width: 320px;    height: 100%;    background-color: #fff;    z-index: $z-index-modal;    transform: translateX(100%);    transition: transform 0.3s ease;    display: flex;    flex-direction: column;    box-shadow: $shadow-lg;    &.is-active {        transform: translateX(0);    }    &__header {        display: flex;        align-items: center;        justify-content: space-between;        padding: $spacing-md;        border-bottom: 1px solid $gray-200;    }    &__links {        padding: $spacing-md;        display: flex;        flex-direction: column;        flex-grow: 1;    }    .mobile-nav-link {        font-size: 1.125rem;        font-weight: $font-weight-medium;        color: var(--ion-color-dark);        text-decoration: none;        padding: $spacing-md 0;        border-bottom: 1px solid $gray-100;        transition: color $transition-fast;        &:hover {            color: var(--ion-color-primary);        }    }}:global(body.menu-open) {    overflow: hidden;}.hero-section {    min-height: 90vh;    display: flex;    align-items: center;    overflow: hidden;    position: relative;}.hero-content {    display: flex;    flex-direction: column;    align-items: center;    padding: $spacing-xl 0;    @media (min-width: $breakpoint-md) {        flex-direction: row;        align-items: center;        padding: $spacing-xxl 0;    }}.hero-text {    flex: 1;    text-align: center;    margin-bottom: $spacing-xl;    @media (min-width: $breakpoint-md) {        text-align: left;        margin-bottom: 0;        margin-right: $spacing-xl;    }}.hero-title {    font-size: 2.25rem;    font-weight: $font-weight-bold;    margin-bottom: $spacing-md;    color: #fff;    line-height: 1.2;    @media (min-width: $breakpoint-md) {        font-size: 3rem;    }}.hero-subtitle {    font-size: 1.125rem;    margin-bottom: $spacing-lg;    color: rgba(255, 255, 255, 0.9);    line-height: 1.6;    @media (min-width: $breakpoint-md) {        font-size: 1.25rem;    }}.hero-cta {    display: flex;    flex-direction: column;    gap: $spacing-md;    @media (min-width: $breakpoint-sm) {        flex-direction: row;        justify-content: center;    }    @media (min-width: $breakpoint-md) {        justify-content: flex-start;    }}.hero-image {    flex: 1;    display: flex;    justify-content: center;    img {        max-width: 100%;        height: auto;        max-height: 400px;        @media (min-width: $breakpoint-md) {            max-height: 500px;        }    }}.stats-section {    background-color: #fff;    padding: $spacing-xl 0;    border-bottom: 1px solid $gray-200;}.stats-grid {    display: grid;    grid-template-columns: repeat(2, 1fr);    gap: $spacing-md;    @media (min-width: $breakpoint-md) {        grid-template-columns: repeat(4, 1fr);    }}.stat-card {    text-align: center;    padding: $spacing-lg;    .stat-number {        font-size: 2rem;        font-weight: $font-weight-bold;        color: var(--ion-color-primary);        margin-bottom: $spacing-xs;        @media (min-width: $breakpoint-md) {            font-size: 2.5rem;        }    }    .stat-label {        font-size: 1rem;        color: $gray-600;        font-weight: $font-weight-medium;    }}.section-header {    text-align: center;    margin-bottom: $spacing-xl;    max-width: 800px;    margin-left: auto;    margin-right: auto;}.section-title {    font-size: 2rem;    font-weight: $font-weight-bold;    color: var(--ion-color-dark);    margin-bottom: $spacing-md;    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.section-subtitle {    font-size: 1.125rem;    color: $gray-600;    line-height: 1.6;}.features-section {    padding: $spacing-xxl 0;    background-color: $gray-50;}.features-grid {    display: grid;    grid-template-columns: 1fr;    gap: $spacing-lg;    @media (min-width: $breakpoint-sm) {        grid-template-columns: repeat(2, 1fr);    }    @media (min-width: $breakpoint-lg) {        grid-template-columns: repeat(3, 1fr);    }}.how-it-works-section {    padding: $spacing-xxl 0;    background-color: #fff;}.steps-container {    position: relative;    max-width: 800px;    margin: 0 auto;}.step-card {    display: flex;    align-items: flex-start;    margin-bottom: $spacing-xl;    position: relative;    z-index: 1;    background-color: #fff;    padding: $spacing-lg;    border-radius: $border-radius-lg;    box-shadow: $shadow-md;    @media (min-width: $breakpoint-md) {        padding: $spacing-xl;    }    &:last-child {        margin-bottom: 0;    }}.step-number {    display: flex;    align-items: center;    justify-content: center;    width: 40px;    height: 40px;    background-color: var(--ion-color-primary);    color: #fff;    border-radius: 50%;    font-weight: $font-weight-bold;    font-size: 1.25rem;    margin-right: $spacing-md;    flex-shrink: 0;    @media (min-width: $breakpoint-md) {        width: 50px;        height: 50px;        font-size: 1.5rem;    }}.step-content {    flex-grow: 1;}.step-title {    font-size: 1.25rem;    font-weight: $font-weight-semibold;    margin-bottom: $spacing-xs;    color: var(--ion-color-dark);    @media (min-width: $breakpoint-md) {        font-size: 1.5rem;    }}.step-description {    font-size: 1rem;    color: $gray-600;    line-height: 1.6;}.step-icon {    margin-left: $spacing-md;    flex-shrink: 0;    font-size: 2rem;    color: var(--ion-color-secondary);    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.step-connector {    position: absolute;    top: 20px;    bottom: 20px;    left: 20px;    width: 2px;    background-color: var(--ion-color-primary);    z-index: 0;    @media (min-width: $breakpoint-md) {        left: 25px;    }}.testimonials-section {    padding: $spacing-xxl 0;    background-color: $gray-50;}.cta-section {    text-align: center;    overflow: hidden;}.cta-content {    padding: $spacing-xxl 0;    color: #fff;}.cta-title {    font-size: 2rem;    font-weight: $font-weight-bold;    margin-bottom: $spacing-md;    @media (min-width: $breakpoint-md) {        font-size: 2.5rem;    }}.cta-subtitle {    font-size: 1.125rem;    margin-bottom: $spacing-lg;    max-width: 600px;    margin-left: auto;    margin-right: auto;    @media (min-width: $breakpoint-md) {        font-size: 1.25rem;    }}.landing-footer {    background-color: $gray-900;    color: $gray-300;    padding: $spacing-xl 0 $spacing-lg;}.footer-grid {    display: grid;    grid-template-columns: 1fr;    gap: $spacing-xl;    margin-bottom: $spacing-xl;    @media (min-width: $breakpoint-md) {        grid-template-columns: 1fr 2fr;    }}.footer-brand {    .landing-logo {        margin-bottom: $spacing-md;        .logo-text {            color: #fff;        }    }}.footer-tagline {    margin-bottom: $spacing-md;    font-size: 1rem;    line-height: 1.6;}.social-links {    display: flex;    gap: $spacing-md;}.social-link {    display: flex;    align-items: center;    justify-content: center;    width: 40px;    height: 40px;    border-radius: 50%;    background-color: rgba(255, 255, 255, 0.1);    color: #fff;    font-size: 1.25rem;    transition: background-color $transition-fast;    &:hover {        background-color: var(--ion-color-primary);    }}.footer-links {    display: grid;    grid-template-columns: repeat(1, 1fr);    gap: $spacing-xl;    @media (min-width: $breakpoint-sm) {        grid-template-columns: repeat(2, 1fr);    }    @media (min-width: $breakpoint-md) {        grid-template-columns: repeat(3, 1fr);    }}.footer-link-group {    .footer-link-title {        color: #fff;        font-size: 1.125rem;        font-weight: $font-weight-semibold;        margin-bottom: $spacing-md;    }    .footer-link {        display: block;        color: $gray-400;        text-decoration: none;        margin-bottom: $spacing-sm;        transition: color $transition-fast;        &:hover {            color: #fff;        }    }}.footer-bottom {    display: flex;    flex-direction: column;    gap: $spacing-md;    padding-top: $spacing-md;    border-top: 1px solid rgba(255, 255, 255, 0.1);    @media (min-width: $breakpoint-md) {        flex-direction: row;        justify-content: space-between;        align-items: center;    }}.copyright {    font-size: 0.875rem;    color: $gray-500;}.footer-legal {    display: flex;    flex-wrap: wrap;    gap: $spacing-md;}.legal-link {    font-size: 0.875rem;    color: $gray-500;    text-decoration: none;    &:hover {        color: #fff;    }}</style>


// src/views/HomePage.vue
<template>  <ion-page>    <ion-header :translucent="true">      <ion-toolbar>        <ion-title>Blank</ion-title>      </ion-toolbar>    </ion-header>    <ion-content :fullscreen="true">      <ion-header collapse="condense">        <ion-toolbar>          <ion-title size="large">Blank</ion-title>        </ion-toolbar>      </ion-header>      <div id="container">        <strong>Ready to create an app?</strong>        <p>Start with Ionic <a target="_blank" rel="noopener noreferrer" href="https://ionicframework.com/docs/components">UI Components</a></p>      </div>    </ion-content>  </ion-page></template><script setup lang="ts">import { IonContent, IonHeader, IonPage, IonTitle, IonToolbar } from '@ionic/vue';</script><style scoped>#container {  text-align: center;    position: absolute;  left: 0;  right: 0;  top: 50%;  transform: translateY(-50%);}#container strong {  font-size: 20px;  line-height: 26px;}#container p {  font-size: 16px;  line-height: 22px;    color: #8c8c8c;    margin: 0;}#container a {  text-decoration: none;}</style>


// src/services/auth.service.ts
import { apiService } from "./api";import {  UserCredentials,  RegistrationData,  ApiResponse,  ValidationError,  UserProfile,} from "@/types";interface AuthResponse {  token: string;  user: UserProfile;}interface PasswordResetRequest {  email: string;}interface PasswordResetCompletion {  token: string;  password: string;  confirmPassword?: string;}/** * Service for handling authentication operations */export const authService = {  /**   * Authenticate user with credentials   * @param credentials - User login credentials   * @returns Promise with authentication response   */  async login(    credentials: UserCredentials  ): Promise<ApiResponse<AuthResponse>> {    // Validate input    if (!credentials?.email) {      return this.createValidationErrorResponse("Email is required");    }    if (!credentials?.password) {      return this.createValidationErrorResponse("Password is required");    }    // Email format validation    if (!this.isValidEmail(credentials.email)) {      return this.createValidationErrorResponse("Invalid email format");    }    try {      return await apiService.post<AuthResponse>("/auth/login", credentials);    } catch (error) {      console.error("[AuthService] Login error:", error);      // Normalize and return error      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Authentication failed",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Register new user   * @param userData - User registration data   * @returns Promise with registration response   */  async register(    userData: RegistrationData  ): Promise<ApiResponse<AuthResponse>> {    // Validate required fields    const requiredFields: (keyof RegistrationData)[] = [      "email",      "password",      "name",      "termsAccepted",    ];    for (const field of requiredFields) {      if (!userData[field]) {        return this.createValidationErrorResponse(`${field} is required`);      }    }    // Validate terms acceptance    if (!userData.termsAccepted) {      return this.createValidationErrorResponse(        "Terms and conditions must be accepted"      );    }    // Email format validation    if (!this.isValidEmail(userData.email)) {      return this.createValidationErrorResponse("Invalid email format");    }    // Password strength validation    if (userData.password.length < 8) {      return this.createValidationErrorResponse(        "Password must be at least 8 characters long"      );    }    try {      // Remove confirmPassword if present (not needed on backend)      const { confirmPassword, ...dataToSend } = userData as any;      return await apiService.post<AuthResponse>("/auth/register", dataToSend);    } catch (error) {      console.error("[AuthService] Registration error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Registration failed",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Validate authentication token   * @param token - Authentication token   * @returns Promise with validation response   */  async validate(token: string): Promise<ApiResponse<{ user: UserProfile }>> {    if (!token) {      return this.createValidationErrorResponse("Token is required");    }    try {      return await apiService.post<{ user: UserProfile }>("/auth/validate", {        token,      });    } catch (error) {      console.error("[AuthService] Token validation error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Token validation failed",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Request password reset   * @param email - User email   * @returns Promise with request response   */  async requestPasswordReset(    email: string  ): Promise<ApiResponse<{ message: string }>> {    if (!email) {      return this.createValidationErrorResponse("Email is required");    }    if (!this.isValidEmail(email)) {      return this.createValidationErrorResponse("Invalid email format");    }    try {      return await apiService.post<{ message: string }>(        "/auth/reset-password",        { email }      );    } catch (error) {      console.error("[AuthService] Password reset request error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Password reset request failed",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Complete password reset with token   * @param resetData - Password reset completion data   * @returns Promise with completion response   */  async completePasswordReset(    resetData: PasswordResetCompletion  ): Promise<ApiResponse<{ message: string }>> {    // Validate required fields    if (!resetData.token) {      return this.createValidationErrorResponse("Reset token is required");    }    if (!resetData.password) {      return this.createValidationErrorResponse("New password is required");    }    // Password strength validation    if (resetData.password.length < 8) {      return this.createValidationErrorResponse(        "Password must be at least 8 characters long"      );    }    // Password confirmation validation    if (      resetData.confirmPassword &&      resetData.password !== resetData.confirmPassword    ) {      return this.createValidationErrorResponse("Passwords do not match");    }    try {      // Remove confirmPassword if present (not needed on backend)      const { confirmPassword, ...dataToSend } = resetData;      return await apiService.post<{ message: string }>(        "/auth/complete-reset",        dataToSend      );    } catch (error) {      console.error("[AuthService] Password reset completion error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Password reset completion failed",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Create a standard validation error response   * @param message - Error message   * @returns Formatted error response   */  createValidationErrorResponse<T>(message: string): ApiResponse<T> {    return {      success: false,      error: {        message,        type: "ValidationError",      },    };  },  /**   * Validate email format   * @param email - Email to validate   * @returns Whether email is valid   */  isValidEmail(email: string): boolean {    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;    return emailRegex.test(email);  },};export default authService;


// src/services/api.ts
import axios, {  AxiosRequestConfig,  AxiosResponse,  AxiosError,  AxiosInstance,} from "axios";import {  ApiResponse,  ApiSuccessResponse,  ApiErrorResponse,  NetworkError,} from "@/types";const API_URL = process.env.VUE_APP_API_URL || "https://api.example.com";const API_TIMEOUT = 15000;const API_RETRY_ATTEMPTS = 2;const API_RETRY_DELAY = 1000;type ProgressCallback = (progressEvent: {  loaded: number;  total: number;  percentage: number;}) => void;const apiClient: AxiosInstance = axios.create({  baseURL: API_URL,  timeout: API_TIMEOUT,  headers: {    "Content-Type": "application/json",    Accept: "application/json",  },});apiClient.interceptors.request.use(  (config: AxiosRequestConfig): AxiosRequestConfig => {    // Track request start time for performance monitoring    (config as any).metadata = { startTime: new Date().getTime() };    // Add auth token if available    try {      const token = localStorage.getItem("auth_token");      if (token) {        config.headers = config.headers || {};        config.headers["Authorization"] = `Bearer ${token}`;      }    } catch (err) {      console.error("[APIClient] Error accessing localStorage:", err);    }    // Log request in development    if (process.env.NODE_ENV === "development") {      console.log(`[APIClient] ${config.method?.toUpperCase()} ${config.url}`);    }    return config;  },  (error: any): Promise<never> => {    console.error("[APIClient] Request preparation error:", error);    return Promise.reject(error);  });apiClient.interceptors.response.use(  (response: AxiosResponse): ApiSuccessResponse => {    // Calculate request duration for performance monitoring    const requestDuration = calculateRequestDuration(response);    logPerformanceMetrics(response.config, requestDuration);    // Transform successful responses    return {      success: true,      data: response.data,      status: response.status,      headers: response.headers as Record<string, string>,    };  },  (error: AxiosError): Promise<ApiErrorResponse> => {    // Calculate request duration even for errors    const requestDuration = calculateRequestDuration(error);    logPerformanceMetrics(error.config, requestDuration);    // Transform error responses    const errorResponse: ApiErrorResponse = {      success: false,      error: {        message: "Network error",        type: "NetworkError",        status: 500,      },      originalError: error,    };    if (error.response) {      // Server responded with an error      errorResponse.error = {        message: error.response.data.message || "Server error",        type: "ServerError",        status: error.response.status,        data: error.response.data,      };      // Handle specific status codes      if (error.response.status === 401) {        // Unauthorized - clear auth and redirect to login        try {          localStorage.removeItem("auth_token");          // Don't redirect if this is a login/validate request          const isAuthRequest = error.config.url?.includes("/auth/");          if (!isAuthRequest) {            window.location.href = "/login";          }        } catch (localStorageError) {          console.error(            "[APIClient] Error clearing localStorage:",            localStorageError          );        }      }    } else if (error.request) {      // No response received      errorResponse.error = {        message: "No response from server",        type: "TimeoutError",        status: 0,      };    }    console.error(      `[APIClient] ${error.config?.method?.toUpperCase() || "REQUEST"} ${        error.config?.url      } failed:`,      errorResponse.error    );    return Promise.resolve(errorResponse);  });function calculateRequestDuration(  response: AxiosResponse | AxiosError): number {  try {    const config =      (response as AxiosResponse)?.config || (response as AxiosError)?.config;    const startTime = (config as any)?.metadata?.startTime;    if (startTime) {      return new Date().getTime() - startTime;    }  } catch (error) {    console.error("[APIClient] Error calculating request duration:", error);  }  return 0;}function logPerformanceMetrics(config: any, duration: number): void {  if (duration > 1000) {    console.warn(      `[APIClient] Slow request: ${config?.method?.toUpperCase()} ${        config?.url      } took ${duration}ms`    );  }  if (process.env.NODE_ENV === "development") {    console.log(      `[APIClient] ${config?.method?.toUpperCase()} ${        config?.url      } completed in ${duration}ms`    );  }}async function executeWithRetry<T>(  requestFn: () => Promise<ApiResponse<T>>,  maxRetries: number = API_RETRY_ATTEMPTS): Promise<ApiResponse<T>> {  let lastError: ApiErrorResponse | null = null;  let retryCount = 0;  while (retryCount <= maxRetries) {    try {      const response = await requestFn();      // Don't retry 4xx errors (client errors)      if (        !response.success &&        response.error.status &&        response.error.status >= 400 &&        response.error.status < 500      ) {        return response;      }      // Return successful response or 5xx error after max retries      if (response.success || retryCount === maxRetries) {        return response;      }      // Store error for potential retry      lastError = response as ApiErrorResponse;      // Exponential backoff      const delay = API_RETRY_DELAY * Math.pow(2, retryCount);      console.warn(        `[APIClient] Retrying request (${retryCount + 1}/${          maxRetries + 1        }) after ${delay}ms`      );      await new Promise((resolve) => setTimeout(resolve, delay));      retryCount++;    } catch (error) {      console.error(        `[APIClient] Unexpected error during retry (${retryCount}/${maxRetries}):`,        error      );      if (retryCount === maxRetries) {        throw error;      }      retryCount++;    }  }  return (    lastError || {      success: false,      error: {        message: "Maximum retries exceeded",        type: "RetryLimitError",      },    }  );}export const apiService = {  /**   * Perform GET request   * @param url - Endpoint URL   * @param params - Query parameters   * @param options - Additional axios options   * @returns Promise with typed response   */  get: async <T = any>(    url: string,    params: Record<string, any> = {},    options: Partial<AxiosRequestConfig> = {}  ): Promise<ApiResponse<T>> => {    try {      return await executeWithRetry<T>(() =>        apiClient.get(url, { params, ...options })      );    } catch (error) {      console.error(`[APIClient] GET ${url} failed:`, error);      throw new NetworkError(`Failed to fetch data from ${url}`);    }  },  /**   * Perform POST request   * @param url - Endpoint URL   * @param data - Request payload   * @param options - Additional axios options   * @returns Promise with typed response   */  post: async <T = any>(    url: string,    data: Record<string, any> = {},    options: Partial<AxiosRequestConfig> = {}  ): Promise<ApiResponse<T>> => {    try {      return await executeWithRetry<T>(() =>        apiClient.post(url, data, options)      );    } catch (error) {      console.error(`[APIClient] POST ${url} failed:`, error);      throw new NetworkError(`Failed to submit data to ${url}`);    }  },  /**   * Perform PUT request   * @param url - Endpoint URL   * @param data - Request payload   * @param options - Additional axios options   * @returns Promise with typed response   */  put: async <T = any>(    url: string,    data: Record<string, any> = {},    options: Partial<AxiosRequestConfig> = {}  ): Promise<ApiResponse<T>> => {    try {      return await executeWithRetry<T>(() => apiClient.put(url, data, options));    } catch (error) {      console.error(`[APIClient] PUT ${url} failed:`, error);      throw new NetworkError(`Failed to update data at ${url}`);    }  },  /**   * Perform DELETE request   * @param url - Endpoint URL   * @param options - Additional axios options   * @returns Promise with typed response   */  delete: async <T = any>(    url: string,    options: Partial<AxiosRequestConfig> = {}  ): Promise<ApiResponse<T>> => {    try {      return await executeWithRetry<T>(() => apiClient.delete(url, options));    } catch (error) {      console.error(`[APIClient] DELETE ${url} failed:`, error);      throw new NetworkError(`Failed to delete resource at ${url}`);    }  },  /**   * Upload file with progress tracking   * @param url - Upload endpoint URL   * @param formData - FormData with files   * @param onProgress - Optional progress callback   * @returns Promise with typed response   */  upload: async <T = any>(    url: string,    formData: FormData,    onProgress: ProgressCallback | null = null  ): Promise<ApiResponse<T>> => {    try {      const config: AxiosRequestConfig = {        headers: {          "Content-Type": "multipart/form-data",        },      };      if (onProgress) {        config.onUploadProgress = (progressEvent: any) => {          const percentage = Math.round(            (progressEvent.loaded * 100) / (progressEvent.total || 1) // Avoid division by zero          );          onProgress({            loaded: progressEvent.loaded,            total: progressEvent.total || 0,            percentage,          });        };      }      // Upload requests can take longer, so increase timeout      config.timeout = API_TIMEOUT * 3;      // Note: we don't use retry for uploads as they can cause duplicate uploads      return await apiClient.post(url, formData, config);    } catch (error) {      console.error(`[APIClient] UPLOAD to ${url} failed:`, error);      throw new NetworkError(`Failed to upload file to ${url}`);    }  },  /**   * Cancel pending requests matching a specific identifier   * @param requestId - Identifier to match pending requests   */  cancelRequests: (requestId: string): void => {    // Implementation would depend on maintaining a map of request cancel tokens    console.warn("[APIClient] Request cancellation not yet implemented");  },  /**   * Clear any cached responses   */  clearCache: (): void => {    // Implementation would depend on your caching strategy    console.warn("[APIClient] Cache clearing not yet implemented");  },};


// src/services/user.service.ts
import { apiService } from "./api";import {  ApiResponse,  ValidationError,  UserProfile,  ApplicationStatus,  NotificationPreferences,} from "@/types";interface ProfileUpdateData {  name?: string;  phone?: string;  profession?: string;  experience?: number;  bio?: string;  skills?: string[];}interface UpcomingEvent {  id: string;  type: "call" | "interview" | "meeting";  title: string;  description?: string;  scheduledFor: string; // ISO date  duration?: number; // in minutes  location?: string;  participants?: Array<{    id: string;    name: string;    role: string;  }>;  status: "scheduled" | "completed" | "cancelled";}/** * Service for handling user-related operations */export const userService = {  /**   * Get current user profile   * @returns Promise with user profile data   */  async getProfile(): Promise<ApiResponse<UserProfile>> {    try {      return await apiService.get<UserProfile>("/user/profile");    } catch (error) {      console.error("[UserService] Get profile error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to fetch profile",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Update user profile   * @param profileData - Updated profile data   * @returns Promise with update result   */  async updateProfile(    profileData: ProfileUpdateData  ): Promise<ApiResponse<UserProfile>> {    if (!profileData || Object.keys(profileData).length === 0) {      return {        success: false,        error: {          message: "No profile data provided for update",          type: "ValidationError",        },      };    }    // Validate inputs    if (profileData.name !== undefined && profileData.name.trim() === "") {      return {        success: false,        error: {          message: "Name cannot be empty",          type: "ValidationError",        },      };    }    if (profileData.experience !== undefined && profileData.experience < 0) {      return {        success: false,        error: {          message: "Experience cannot be negative",          type: "ValidationError",        },      };    }    // Limit bio length    if (profileData.bio !== undefined && profileData.bio.length > 1000) {      return {        success: false,        error: {          message: "Bio is too long, maximum 1000 characters",          type: "ValidationError",        },      };    }    // Validate skills array    if (profileData.skills !== undefined) {      if (!Array.isArray(profileData.skills)) {        return {          success: false,          error: {            message: "Skills must be an array",            type: "ValidationError",          },        };      }      // Check for empty skills      if (profileData.skills.some((skill) => !skill || skill.trim() === "")) {        return {          success: false,          error: {            message: "Skills cannot contain empty values",            type: "ValidationError",          },        };      }    }    try {      return await apiService.put<UserProfile>("/user/profile", profileData);    } catch (error) {      console.error("[UserService] Update profile error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to update profile",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Get user's application status   * @returns Promise with application status data   */  async getApplicationStatus(): Promise<ApiResponse<ApplicationStatus>> {    try {      return await apiService.get<ApplicationStatus>(        "/user/application-status"      );    } catch (error) {      console.error("[UserService] Get application status error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Failed to fetch application status",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Get user's upcoming events (calls, interviews)   * @returns Promise with upcoming events data   */  async getUpcomingEvents(): Promise<ApiResponse<UpcomingEvent[]>> {    try {      return await apiService.get<UpcomingEvent[]>("/user/events");    } catch (error) {      console.error("[UserService] Get events error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Failed to fetch upcoming events",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Update user's notification preferences   * @param preferences - Notification preferences   * @returns Promise with update result   */  async updateNotificationPreferences(    preferences: NotificationPreferences  ): Promise<ApiResponse<NotificationPreferences>> {    if (!preferences) {      return {        success: false,        error: {          message: "Notification preferences are required",          type: "ValidationError",        },      };    }    try {      return await apiService.put<NotificationPreferences>(        "/user/notification-preferences",        preferences      );    } catch (error) {      console.error(        "[UserService] Update notification preferences error:",        error      );      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Failed to update notification preferences",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Confirm or decline an event   * @param eventId - ID of the event   * @param status - New status (confirm/decline)   * @returns Promise with update result   */  async respondToEvent(    eventId: string,    status: "confirm" | "decline",    comment?: string  ): Promise<ApiResponse<{ message: string }>> {    if (!eventId) {      return {        success: false,        error: {          message: "Event ID is required",          type: "ValidationError",        },      };    }    try {      return await apiService.post<{ message: string }>(        `/user/events/${eventId}/respond`,        { status, comment }      );    } catch (error) {      console.error("[UserService] Event response error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Failed to respond to event",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Get summary of user's profile completion status   * @returns Promise with profile completion data   */  async getProfileCompletionStatus(): Promise<    ApiResponse<{      completionPercentage: number;      missingFields: string[];      recommendations: string[];    }>  > {    try {      return await apiService.get("/user/profile-completion");    } catch (error) {      console.error("[UserService] Profile completion status error:", error);      return {        success: false,        error: {          message:            error instanceof Error              ? error.message              : "Failed to fetch profile completion status",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },};export default userService;


// src/services/upload.service.ts
import { apiService } from "./api";import { ApiResponse, ValidationError, UploadProgressEvent } from "@/types";type ProgressCallback = (event: UploadProgressEvent) => void;interface UploadResult {  fileUrl: string;  fileKey: string;  filename: string;  mimeType: string;  size: number;}interface PresignedUrlResult {  uploadUrl: string;  fileKey: string;  fields?: Record<string, string>;}/** * Utility for validating file uploads */const fileValidation = {  /**   * Validate CV file   * @param file - File to validate   * @returns Validation result with error message if invalid   */  validateCV(file: File): { valid: boolean; message?: string } {    // Validate file type    const allowedTypes = [      "application/pdf",      "application/msword",      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",      "application/vnd.oasis.opendocument.text",    ];    if (!allowedTypes.includes(file.type)) {      return {        valid: false,        message: "Invalid file type. Please upload a PDF or Word document.",      };    }    // Validate file size (max 5MB)    const maxSize = 5 * 1024 * 1024; // 5MB    if (file.size > maxSize) {      return {        valid: false,        message: "File too large. Maximum size is 5MB.",      };    }    // Validate file name length    if (file.name.length > 100) {      return {        valid: false,        message: "File name is too long. Maximum length is 100 characters.",      };    }    return { valid: true };  },  /**   * Validate photo file   * @param file - File to validate   * @returns Validation result with error message if invalid   */  validatePhoto(file: File): { valid: boolean; message?: string } {    // Validate file type    const allowedTypes = ["image/jpeg", "image/png", "image/gif", "image/webp"];    if (!allowedTypes.includes(file.type)) {      return {        valid: false,        message:          "Invalid file type. Please upload a JPEG, PNG, GIF, or WebP image.",      };    }    // Validate file size (max 2MB)    const maxSize = 2 * 1024 * 1024; // 2MB    if (file.size > maxSize) {      return {        valid: false,        message: "File too large. Maximum size is 2MB.",      };    }    return { valid: true };  },};/** * Service for handling file uploads */export const uploadService = {  /**   * Upload CV document   * @param file - CV file   * @param onProgress - Progress callback   * @returns Promise with upload result   */  async uploadCV(    file: File,    onProgress: ProgressCallback | null = null  ): Promise<ApiResponse<UploadResult>> {    if (!file) {      return {        success: false,        error: {          message: "CV file is required",          type: "ValidationError",        },      };    }    // Validate file    const validation = fileValidation.validateCV(file);    if (!validation.valid) {      return {        success: false,        error: {          message: validation.message || "Invalid file",          type: "ValidationError",        },      };    }    try {      // If direct upload is enabled, use the presigned URL method      if (process.env.VUE_APP_ENABLE_DIRECT_UPLOAD === "true") {        return await this.uploadWithPresignedUrl("cv", file, onProgress);      }      // Otherwise use the standard server-mediated upload      const formData = new FormData();      formData.append("cv", file);      return await apiService.upload<UploadResult>(        "/user/upload-cv",        formData,        onProgress      );    } catch (error) {      console.error("[UploadService] CV upload error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to upload CV",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Upload profile photo   * @param file - Photo file   * @param onProgress - Progress callback   * @returns Promise with upload result   */  async uploadPhoto(    file: File,    onProgress: ProgressCallback | null = null  ): Promise<ApiResponse<UploadResult>> {    if (!file) {      return {        success: false,        error: {          message: "Photo file is required",          type: "ValidationError",        },      };    }    // Validate file    const validation = fileValidation.validatePhoto(file);    if (!validation.valid) {      return {        success: false,        error: {          message: validation.message || "Invalid file",          type: "ValidationError",        },      };    }    try {      // If direct upload is enabled, use the presigned URL method      if (process.env.VUE_APP_ENABLE_DIRECT_UPLOAD === "true") {        return await this.uploadWithPresignedUrl("photo", file, onProgress);      }      // Otherwise use the standard server-mediated upload      const formData = new FormData();      formData.append("photo", file);      return await apiService.upload<UploadResult>(        "/user/upload-photo",        formData,        onProgress      );    } catch (error) {      console.error("[UploadService] Photo upload error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to upload photo",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Get presigned URL for direct upload to cloud storage   * @param uploadType - Type of upload (cv/photo)   * @param file - File to upload   * @returns Promise with presigned URL data   */  async getPresignedUrl(    uploadType: string,    file: File  ): Promise<ApiResponse<PresignedUrlResult>> {    if (!file) {      return {        success: false,        error: {          message: "File is required",          type: "ValidationError",        },      };    }    try {      return await apiService.post<PresignedUrlResult>(        "/uploads/presigned-url",        {          fileType: file.type,          fileName: file.name,          fileSize: file.size,          uploadType,        }      );    } catch (error) {      console.error("[UploadService] Presigned URL error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to get upload URL",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },  /**   * Upload file using presigned URL (direct-to-S3 upload)   * @param uploadType - Type of upload (cv/photo)   * @param file - File to upload   * @param onProgress - Progress callback   * @returns Promise with upload result   */  async uploadWithPresignedUrl(    uploadType: string,    file: File,    onProgress: ProgressCallback | null = null  ): Promise<ApiResponse<UploadResult>> {    try {      // Step 1: Get presigned URL from server      const presignedUrlResponse = await this.getPresignedUrl(uploadType, file);      if (!presignedUrlResponse.success) {        return presignedUrlResponse as ApiResponse<UploadResult>;      }      const { uploadUrl, fileKey, fields } = presignedUrlResponse.data;      // Step 2: Upload to storage provider directly      const formData = new FormData();      // Add any required fields for the storage provider      if (fields) {        Object.entries(fields).forEach(([key, value]) => {          formData.append(key, value);        });      }      // Add the file as the last field      formData.append("file", file);      // Create custom XHR request to track progress      return new Promise((resolve) => {        const xhr = new XMLHttpRequest();        xhr.upload.onprogress = (event) => {          if (onProgress && event.lengthComputable) {            onProgress({              loaded: event.loaded,              total: event.total,              percentage: Math.round((event.loaded * 100) / event.total),            });          }        };        xhr.onload = async () => {          if (xhr.status >= 200 && xhr.status < 300) {            // Step 3: Notify server about successful upload            const confirmResponse = await apiService.post<UploadResult>(              "/uploads/confirm",              {                fileKey,                fileName: file.name,                fileSize: file.size,                mimeType: file.type,                uploadType,              }            );            resolve(confirmResponse);          } else {            resolve({              success: false,              error: {                message: `Upload failed with status ${xhr.status}`,                type: "UploadError",                status: xhr.status,              },            });          }        };        xhr.onerror = () => {          resolve({            success: false,            error: {              message: "Network error during upload",              type: "NetworkError",            },          });        };        xhr.onabort = () => {          resolve({            success: false,            error: {              message: "Upload aborted",              type: "UploadAbortedError",            },          });        };        xhr.open("POST", uploadUrl, true);        xhr.send(formData);      });    } catch (error) {      console.error("[UploadService] Presigned URL upload error:", error);      return {        success: false,        error: {          message:            error instanceof Error ? error.message : "Failed to upload file",          type:            error instanceof Error ? error.constructor.name : "UnknownError",        },      };    }  },};export default uploadService;


// src/store/appStore.ts
import { defineStore } from "pinia";import { ref, computed } from "vue";import { authService } from "@/services/auth.service";import {  UserProfile,  UserCredentials,  Notification,  RegistrationData,  ApiResponse,  ValidationError,} from "@/types";interface LoginResult {  success: boolean;  error?: {    message: string;    type: string;  };}export const useAppStore = defineStore("app", () => {  // State  const user = ref<UserProfile | null>(null);  const authToken = ref<string | null>(null);  const isLoading = ref<boolean>(false);  const error = ref<{ message: string; type: string } | null>(null);  const notifications = ref<Notification[]>([]);  // Computed  const isAuthenticated = computed<boolean>(() => !!authToken.value);  const userProfile = computed<UserProfile | {}>(() => user.value || {});  const hasNotifications = computed<boolean>(    () => notifications.value.length > 0  );  const unreadNotificationsCount = computed<number>(    () => notifications.value.filter((n) => !n.read).length  );  // Error handling helper  const handleError = (err: unknown): { message: string; type: string } => {    if (err instanceof Error) {      return {        message: err.message,        type: err.constructor.name,      };    } else {      return {        message: "An unknown error occurred",        type: "UnknownError",      };    }  };  // Actions  async function login(credentials: UserCredentials): Promise<LoginResult> {    // Input validation    if (!credentials?.email || !credentials?.password) {      return {        success: false,        error: {          message: "Email and password are required",          type: "ValidationError",        },      };    }    try {      isLoading.value = true;      error.value = null;      const response = await authService.login(credentials);      if (response.success) {        authToken.value = response.data.token;        user.value = response.data.user;        localStorage.setItem("auth_token", response.data.token);        return { success: true };      } else {        error.value = response.error;        return { success: false, error: response.error };      }    } catch (err) {      const normalizedError = handleError(err);      error.value = normalizedError;      console.error("[AuthStore] Login error:", normalizedError);      return {        success: false,        error: normalizedError,      };    } finally {      isLoading.value = false;    }  }  async function register(userData: RegistrationData): Promise<LoginResult> {    // Validate required fields    const requiredFields = ["email", "password", "name", "termsAccepted"];    const missingFields = requiredFields.filter(      (field) => !userData[field as keyof RegistrationData]    );    if (missingFields.length > 0) {      return {        success: false,        error: {          message: `Missing required fields: ${missingFields.join(", ")}`,          type: "ValidationError",        },      };    }    if (!userData.termsAccepted) {      return {        success: false,        error: {          message: "You must accept the terms and conditions",          type: "ValidationError",        },      };    }    try {      isLoading.value = true;      error.value = null;      const response = await authService.register(userData);      if (response.success) {        authToken.value = response.data.token;        user.value = response.data.user;        localStorage.setItem("auth_token", response.data.token);        return { success: true };      } else {        error.value = response.error;        return { success: false, error: response.error };      }    } catch (err) {      const normalizedError = handleError(err);      error.value = normalizedError;      console.error("[AuthStore] Registration error:", normalizedError);      return {        success: false,        error: normalizedError,      };    } finally {      isLoading.value = false;    }  }  function logout(): void {    try {      authToken.value = null;      user.value = null;      localStorage.removeItem("auth_token");    } catch (err) {      console.error("[AuthStore] Logout error:", err);      // Ensure clean state even if error occurs      authToken.value = null;      user.value = null;    }  }  async function restoreSession(token: string): Promise<boolean> {    if (!token) return false;    try {      isLoading.value = true;      const response = await authService.validate(token);      if (response.success) {        authToken.value = token;        user.value = response.data.user;        return true;      } else {        // Invalid token        logout();        return false;      }    } catch (err) {      console.error("[AuthStore] Session restore error:", err);      logout();      return false;    } finally {      isLoading.value = false;    }  }  function addNotification(    notification: Omit<Notification, "id" | "timestamp" | "read">  ): void {    try {      notifications.value.push({        id: Date.now(),        timestamp: new Date(),        read: false,        ...notification,      });    } catch (err) {      console.error("[NotificationStore] Add notification error:", err);    }  }  function markNotificationAsRead(id: string | number): void {    try {      const notification = notifications.value.find((n) => n.id === id);      if (notification) {        notification.read = true;      }    } catch (err) {      console.error("[NotificationStore] Mark notification error:", err);    }  }  function clearNotifications(): void {    try {      notifications.value = [];    } catch (err) {      console.error("[NotificationStore] Clear notifications error:", err);      // Force reset on error      notifications.value = [];    }  }  return {    // State    user,    authToken,    isLoading,    error,    notifications,    // Computed    isAuthenticated,    userProfile,    hasNotifications,    unreadNotificationsCount,    // Actions    login,    register,    logout,    restoreSession,    addNotification,    markNotificationAsRead,    clearNotifications,  };});


// src/router/index.ts
import { createRouter, createWebHistory } from "@ionic/vue-router";import {  RouteRecordRaw,  RouteLocationNormalized,  NavigationGuardNext,} from "vue-router";const LandingPage = () => import("@/views/LandingPage.vue");const RegistrationPage = () => import("@/views/RegistrationPage.vue");const LoginPage = () => import("@/views/LoginPage.vue");const DashboardPage = () => import("@/views/DashboardPage.vue");const ProfilePage = () => import("@/views/ProfilePage.vue");const NotFoundPage = () => import("@/views/NotFoundPage.vue");declare module "vue-router" {  interface RouteMeta {    requiresAuth?: boolean;    requiresTransition?: boolean;    title?: string;  }}const requiresAuth = (  to: RouteLocationNormalized,  from: RouteLocationNormalized,  next: NavigationGuardNext): void => {  try {    const isAuthenticated = localStorage.getItem("auth_token") !== null;    if (isAuthenticated) {      next();    } else {      next({        name: "Login",        query: { redirect: to.fullPath },        params: { authRequired: true },      });    }  } catch (error) {    console.error("[AuthGuard] Authentication check failed:", error);    // Fail safe to login page on error    next({ name: "Login" });  }};const routes: Array<RouteRecordRaw> = [  {    path: "/",    name: "Landing",    component: LandingPage,    meta: {      requiresTransition: true,      title: "Welcome",    },  },  {    path: "/register",    name: "Registration",    component: RegistrationPage,    meta: {      requiresTransition: true,      title: "Create Your Profile",    },  },  {    path: "/login",    name: "Login",    component: LoginPage,    meta: {      requiresTransition: true,      title: "Sign In",    },  },  {    path: "/dashboard",    name: "Dashboard",    component: DashboardPage,    meta: {      requiresAuth: true,      requiresTransition: true,      title: "Your Dashboard",    },    beforeEnter: requiresAuth,  },  {    path: "/profile",    name: "Profile",    component: ProfilePage,    meta: {      requiresAuth: true,      requiresTransition: true,      title: "Your Profile",    },    beforeEnter: requiresAuth,  },  {    path: "/:pathMatch(.*)*",    name: "NotFound",    component: NotFoundPage,    meta: {      title: "Page Not Found",    },  },];const router = createRouter({  history: createWebHistory(process.env.BASE_URL),  routes,  scrollBehavior(to, from, savedPosition) {    if (savedPosition) {      return savedPosition;    } else if (to.hash) {      return {        el: to.hash,        behavior: "smooth" as ScrollBehavior,      };    } else {      return { top: 0 };    }  },});router.afterEach((to) => {  try {    document.title = to.meta.title      ? `${to.meta.title} | Candidate Platform`      : "Candidate Platform";  } catch (error) {    console.error("[Router] Failed to update document title:", error);  }});export default router;


